// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "fmt"
import "reflect"
import "encoding/json"

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchemaPREFERREDURLSCHEME) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuayConfigSchemaPREFERREDURLSCHEME {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuayConfigSchemaPREFERREDURLSCHEME, v)
	}
	*j = QuayConfigSchemaPREFERREDURLSCHEME(v)
	return nil
}

// Schema for Quay configuration
type QuayConfigSchema struct {
	// If action log archiving is enabled, the storage engine in which to place the
	// archived data.
	ACTIONLOGARCHIVELOCATION *string `json:"ACTION_LOG_ARCHIVE_LOCATION,omitempty"`

	// If action log archiving is enabled, the path in storage in which to place the
	// archived data.
	ACTIONLOGARCHIVEPATH *string `json:"ACTION_LOG_ARCHIVE_PATH,omitempty"`

	// If action log archiving is enabled, the time interval after which to archive
	// data.
	ACTIONLOGROTATIONTHRESHOLD *string `json:"ACTION_LOG_ROTATION_THRESHOLD,omitempty"`

	// If true, pulls in which the pull audit log entry cannot be written will still
	// succeed. Useful if the database can fallback into a read-only state and it is
	// desired for pulls to continue during that time. Defaults to False.
	ALLOWPULLSWITHOUTSTRICTLOGGING *bool `json:"ALLOW_PULLS_WITHOUT_STRICT_LOGGING,omitempty"`

	// The expiration for external app tokens. Defaults to None.
	APPSPECIFICTOKENEXPIRATION interface{} `json:"APP_SPECIFIC_TOKEN_EXPIRATION,omitempty"`

	// The authentication engine to use for credential authentication.
	AUTHENTICATIONTYPE QuayConfigSchemaAUTHENTICATIONTYPE `json:"AUTHENTICATION_TYPE"`

	// The types of avatars to display, either generated inline (local) or Gravatar
	// (gravatar)
	AVATARKIND *QuayConfigSchemaAVATARKIND `json:"AVATAR_KIND,omitempty"`

	// Configuration for using BitBucket for build triggers
	BITBUCKETTRIGGERCONFIG interface{} `json:"BITBUCKET_TRIGGER_CONFIG,omitempty"`

	// The array of email-address domains that is used if FEATURE_BLACKLISTED_EMAILS
	// is set to true.
	BLACKLISTEDEMAILDOMAINS []interface{} `json:"BLACKLISTED_EMAIL_DOMAINS,omitempty"`

	// The Docker CLI versions to which Quay will respond that V2 is *unsupported*.
	// Defaults to `<1.6.0`
	BLACKLISTV2SPEC *string `json:"BLACKLIST_V2_SPEC,omitempty"`

	// Custom branding for logos and URLs in the Quay UI
	BRANDING interface{} `json:"BRANDING,omitempty"`

	// If enabled, only API calls marked as being made by an XHR will be allowed from
	// browsers. Defaults to True.
	BROWSERAPICALLSXHRONLY *bool `json:"BROWSER_API_CALLS_XHR_ONLY,omitempty"`

	// Connection information for Redis for build logs caching
	BUILDLOGSREDIS QuayConfigSchemaBUILDLOGSREDIS `json:"BUILDLOGS_REDIS"`

	// If specified, contact information to display on the contact page. If only a
	// single piece of contact information is specified, the contact footer will link
	// directly.
	CONTACTINFO []interface{} `json:"CONTACT_INFO,omitempty"`

	// If specified, connection arguments for the database such as timeouts and SSL.
	DBCONNECTIONARGS *QuayConfigSchemaDBCONNECTIONARGS `json:"DB_CONNECTION_ARGS,omitempty"`

	// The URI at which to access the database, including any credentials.
	DBURI string `json:"DB_URI"`

	// If not None, the default maximum number of builds that can be queued in a
	// namespace.
	DEFAULTNAMESPACEMAXIMUMBUILDCOUNT interface{} `json:"DEFAULT_NAMESPACE_MAXIMUM_BUILD_COUNT,omitempty"`

	// The default, configurable tag expiration time for time machine. Defaults to
	// `2w`.
	DEFAULTTAGEXPIRATION string `json:"DEFAULT_TAG_EXPIRATION"`

	// A list of client IDs of *Quay-managed* applications that are allowed to perform
	// direct OAuth approval without user approval.
	DIRECTOAUTHCLIENTIDWHITELIST []string `json:"DIRECT_OAUTH_CLIENTID_WHITELIST,omitempty"`

	// Configuration for storage engine(s) to use in Quay. Each key is a unique ID for
	// a storage engine, with the value being a tuple of the type and  configuration
	// for that engine.
	DISTRIBUTEDSTORAGECONFIG QuayConfigSchemaDISTRIBUTEDSTORAGECONFIG `json:"DISTRIBUTED_STORAGE_CONFIG"`

	// The list of storage engine(s) (by ID in DISTRIBUTED_STORAGE_CONFIG) whose
	// images should be fully replicated, by default, to all other storage engines.
	DISTRIBUTEDSTORAGEDEFAULTLOCATIONS []string `json:"DISTRIBUTED_STORAGE_DEFAULT_LOCATIONS,omitempty"`

	// The preferred storage engine(s) (by ID in DISTRIBUTED_STORAGE_CONFIG) to use. A
	// preferred engine means it is first checked for pullig and images are pushed to
	// it.
	DISTRIBUTEDSTORAGEPREFERENCE []string `json:"DISTRIBUTED_STORAGE_PREFERENCE"`

	// Root URL for documentation links
	DOCUMENTATIONROOT *string `json:"DOCUMENTATION_ROOT,omitempty"`

	// If specified, a secret that can be given to health endpoints to see full debug
	// info whennot authenticated as a superuser
	ENABLEHEALTHDEBUGSECRET interface{} `json:"ENABLE_HEALTH_DEBUG_SECRET,omitempty"`

	// Duration of time expired external app tokens will remain before being garbage
	// collected. Defaults to 1d.
	EXPIREDAPPSPECIFICTOKENGC interface{} `json:"EXPIRED_APP_SPECIFIC_TOKEN_GC,omitempty"`

	// If TLS is supported, but terminated at a layer before Quay, must be true.
	EXTERNALTLSTERMINATION *bool `json:"EXTERNAL_TLS_TERMINATION,omitempty"`

	// Whether to enable conversion to ACIs. Defaults to False
	FEATUREACICONVERSION *bool `json:"FEATURE_ACI_CONVERSION,omitempty"`

	// Whether or not to rotate old action logs to storage. Defaults to False
	FEATUREACTIONLOGROTATION *bool `json:"FEATURE_ACTION_LOG_ROTATION,omitempty"`

	// Whether the v2/ endpoint is visible. Defaults to True
	FEATUREADVERTISEV2 *bool `json:"FEATURE_ADVERTISE_V2,omitempty"`

	// Whether to allow retrieval of aggregated log counts. Defaults to True
	FEATUREAGGREGATEDLOGCOUNTRETRIEVAL *bool `json:"FEATURE_AGGREGATED_LOG_COUNT_RETRIEVAL,omitempty"`

	//  Whether to allow anonymous users to browse and pull public repositories.
	// Defaults to True
	FEATUREANONYMOUSACCESS *bool `json:"FEATURE_ANONYMOUS_ACCESS,omitempty"`

	// Whether to enable support for App repositories. Defaults to False
	FEATUREAPPREGISTRY *bool `json:"FEATURE_APP_REGISTRY,omitempty"`

	// If enabled, users can create tokens for use by the Docker CLI. Defaults to True
	FEATUREAPPSPECIFICTOKENS *bool `json:"FEATURE_APP_SPECIFIC_TOKENS,omitempty"`

	// Whether to support Bitbucket build triggers. Defaults to False
	FEATUREBITBUCKETBUILD *bool `json:"FEATURE_BITBUCKET_BUILD,omitempty"`

	// If set to true, no new User accounts may be created if their email domain is
	// blacklisted.
	FEATUREBLACKLISTEDEMAILS *bool `json:"FEATURE_BLACKLISTED_EMAILS,omitempty"`

	// Whether to support Dockerfile build. Defaults to True
	FEATUREBUILDSUPPORT *bool `json:"FEATURE_BUILD_SUPPORT,omitempty"`

	// Whether users and organizations are allowed to change the tag expiration for
	// tags in their namespace. Defaults to True.
	FEATURECHANGETAGEXPIRATION *bool `json:"FEATURE_CHANGE_TAG_EXPIRATION,omitempty"`

	// Whether users can directly login to the UI. Defaults to True
	FEATUREDIRECTLOGIN *bool `json:"FEATURE_DIRECT_LOGIN,omitempty"`

	// Whether garbage collection of repositories is enabled. Defaults to True
	FEATUREGARBAGECOLLECTION *bool `json:"FEATURE_GARBAGE_COLLECTION,omitempty"`

	// Whether to support GitHub build triggers. Defaults to False
	FEATUREGITHUBBUILD *bool `json:"FEATURE_GITHUB_BUILD,omitempty"`

	// Whether GitHub login is supported. Defaults to False
	FEATUREGITHUBLOGIN *bool `json:"FEATURE_GITHUB_LOGIN,omitempty"`

	// Whether to support GitLab build triggers. Defaults to False
	FEATUREGITLABBUILD *bool `json:"FEATURE_GITLAB_BUILD,omitempty"`

	// Whether Google login is supported. Defaults to False
	FEATUREGOOGLELOGIN *bool `json:"FEATURE_GOOGLE_LOGIN,omitempty"`

	// Whether users being created must be invited by another user. Defaults to False
	FEATUREINVITEONLYUSERCREATION *bool `json:"FEATURE_INVITE_ONLY_USER_CREATION,omitempty"`

	// Whether to allow for "namespace-less" repositories when pulling and pushing
	// from Docker. Defaults to True
	FEATURELIBRARYSUPPORT *bool `json:"FEATURE_LIBRARY_SUPPORT,omitempty"`

	// Whether to allow exporting of action logs. Defaults to True
	FEATURELOGEXPORT *bool `json:"FEATURE_LOG_EXPORT,omitempty"`

	// Whether emails are enabled. Defaults to True
	FEATUREMAILING *bool `json:"FEATURE_MAILING,omitempty"`

	// If enabled, non-superusers can setup syncing on teams to backing LDAP or
	// Keystone. Defaults To False.
	FEATURENONSUPERUSERTEAMSYNCINGSETUP *bool `json:"FEATURE_NONSUPERUSER_TEAM_SYNCING_SETUP,omitempty"`

	// If set to true, autocompletion will apply to partial usernames. Defaults to
	// True
	FEATUREPARTIALUSERAUTOCOMPLETE *bool `json:"FEATURE_PARTIAL_USER_AUTOCOMPLETE,omitempty"`

	// Whether sessions are permanent. Defaults to True
	FEATUREPERMANENTSESSIONS *bool `json:"FEATURE_PERMANENT_SESSIONS,omitempty"`

	// Whether to proxy all direct download URLs in storage via the registry nginx.
	// Defaults to False
	FEATUREPROXYSTORAGE *bool `json:"FEATURE_PROXY_STORAGE,omitempty"`

	// If set to true, the _catalog endpoint returns public repositories. Otherwise,
	// only private repositories can be returned. Defaults to False
	FEATUREPUBLICCATALOG *bool `json:"FEATURE_PUBLIC_CATALOG,omitempty"`

	// Whether to enable rate limits on API and registry endpoints. Defaults to False
	FEATURERATELIMITS *bool `json:"FEATURE_RATE_LIMITS,omitempty"`

	// If set to true, build logs may be read by those with read access to the repo,
	// rather than only write access or admin access. Defaults to False
	FEATUREREADERBUILDLOGS *bool `json:"FEATURE_READER_BUILD_LOGS,omitempty"`

	// Whether to App repositories are read-only. Defaults to False
	FEATUREREADONLYAPPREGISTRY *bool `json:"FEATURE_READONLY_APP_REGISTRY,omitempty"`

	// Whether Recaptcha is necessary for user login and recovery. Defaults to False
	FEATURERECAPTCHA *bool `json:"FEATURE_RECAPTCHA,omitempty"`

	// Whether to enable support for repository mirroring. Defaults to False
	FEATUREREPOMIRROR *bool `json:"FEATURE_REPO_MIRROR,omitempty"`

	// Whether non-encrypted passwords (as opposed to encrypted tokens) can be used
	// for basic auth. Defaults to False
	FEATUREREQUIREENCRYPTEDBASICAUTH *bool `json:"FEATURE_REQUIRE_ENCRYPTED_BASIC_AUTH,omitempty"`

	// Whether to require invitations when adding a user to a team. Defaults to True
	FEATUREREQUIRETEAMINVITE *bool `json:"FEATURE_REQUIRE_TEAM_INVITE,omitempty"`

	// If set to true, only namespaces listed in V1_PUSH_WHITELIST support V1 push.
	// Defaults to True
	FEATURERESTRICTEDV1PUSH *bool `json:"FEATURE_RESTRICTED_V1_PUSH,omitempty"`

	// If the security scanner is enabled, whether to turn of/off security
	// notificaitons. Defaults to False
	FEATURESECURITYNOTIFICATIONS *bool `json:"FEATURE_SECURITY_NOTIFICATIONS,omitempty"`

	// Whether to turn of/off the security scanner. Defaults to False
	FEATURESECURITYSCANNER *bool `json:"FEATURE_SECURITY_SCANNER,omitempty"`

	// Whether to automatically replicate between storage engines. Defaults to False
	FEATURESTORAGEREPLICATION *bool `json:"FEATURE_STORAGE_REPLICATION,omitempty"`

	// Whether super users are supported. Defaults to True
	FEATURESUPERUSERS *bool `json:"FEATURE_SUPER_USERS,omitempty"`

	// Whether to allow for team membership to be synced from a backing group in the
	// authentication engine (LDAP or Keystone)
	FEATURETEAMSYNCING *bool `json:"FEATURE_TEAM_SYNCING,omitempty"`

	// If set to true, users can confirm their generated usernames. Defaults to True
	FEATUREUSERNAMECONFIRMATION *bool `json:"FEATURE_USERNAME_CONFIRMATION,omitempty"`

	// Whether users can be created (by non-super users). Defaults to True
	FEATUREUSERCREATION *bool `json:"FEATURE_USER_CREATION,omitempty"`

	// Whether to record the last time a user was accessed. Defaults to True
	FEATUREUSERLASTACCESSED *bool `json:"FEATURE_USER_LAST_ACCESSED,omitempty"`

	// If set to true, users will have access to audit logs for their namespace.
	// Defaults to False
	FEATUREUSERLOGACCESS *bool `json:"FEATURE_USER_LOG_ACCESS,omitempty"`

	// Whether to collect and support user metadata. Defaults to False
	FEATUREUSERMETADATA *bool `json:"FEATURE_USER_METADATA,omitempty"`

	// If set to true, users can rename their own namespace. Defaults to False
	FEATUREUSERRENAME *bool `json:"FEATURE_USER_RENAME,omitempty"`

	// The time after which a fresh login requires users to reenter their password
	FRESHLOGINTIMEOUT *string `json:"FRESH_LOGIN_TIMEOUT,omitempty"`

	// Configuration for using GitHub (Enterprise) as an external login provider
	GITHUBLOGINCONFIG interface{} `json:"GITHUB_LOGIN_CONFIG,omitempty"`

	// Configuration for using GitHub (Enterprise) for build triggers
	GITHUBTRIGGERCONFIG interface{} `json:"GITHUB_TRIGGER_CONFIG,omitempty"`

	// Configuration for using Gitlab (Enterprise) for external authentication
	GITLABTRIGGERCONFIG interface{} `json:"GITLAB_TRIGGER_CONFIG,omitempty"`

	// Configuration for using Google for external authentication
	GOOGLELOGINCONFIG interface{} `json:"GOOGLE_LOGIN_CONFIG,omitempty"`

	// The configured health check.
	HEALTHCHECKER interface{} `json:"HEALTH_CHECKER,omitempty"`

	// Logs model for action logs
	LOGSMODEL *QuayConfigSchemaLOGSMODEL `json:"LOGS_MODEL,omitempty"`

	// Logs model config for action logs
	LOGSMODELCONFIG *QuayConfigSchemaLOGSMODELCONFIG `json:"LOGS_MODEL_CONFIG,omitempty"`

	// If builds are enabled, the storage engine in which to place the archived build
	// logs.
	LOGARCHIVELOCATION *string `json:"LOG_ARCHIVE_LOCATION,omitempty"`

	// If builds are enabled, the path in storage in which to place the archived build
	// logs.
	LOGARCHIVEPATH *string `json:"LOG_ARCHIVE_PATH,omitempty"`

	// If specified, the e-mail address used as the `from` when Quay sends e-mails. If
	// none, defaults to `support@quay.io`.
	MAILDEFAULTSENDER interface{} `json:"MAIL_DEFAULT_SENDER,omitempty"`

	// The SMTP password to use when sending e-mails.
	MAILPASSWORD interface{} `json:"MAIL_PASSWORD,omitempty"`

	// The SMTP port to use. If not specified, defaults to 587.
	MAILPORT *float64 `json:"MAIL_PORT,omitempty"`

	// The SMTP server to use for sending e-mails. Only required if FEATURE_MAILING is
	// set to true.
	MAILSERVER *string `json:"MAIL_SERVER,omitempty"`

	// The SMTP username to use when sending e-mails.
	MAILUSERNAME interface{} `json:"MAIL_USERNAME,omitempty"`

	// If specified, whether to use TLS for sending e-mails.
	MAILUSETLS *bool `json:"MAIL_USE_TLS,omitempty"`

	// Maximum allowed size of an image layer. Defaults to 20G
	MAXIMUMLAYERSIZE *string `json:"MAXIMUM_LAYER_SIZE,omitempty"`

	// The URL scheme to use when hitting Quay. If Quay is behind SSL *at all*, this
	// *must* be `https`
	PREFERREDURLSCHEME QuayConfigSchemaPREFERREDURLSCHEME `json:"PREFERRED_URL_SCHEME"`

	// The prefix applied to all exposed Prometheus metrics. Defaults to `quay`
	PROMETHEUSNAMESPACE *string `json:"PROMETHEUS_NAMESPACE,omitempty"`

	// If a namespace is defined in the public namespace list, then it will appear on
	// *all* user's repository list pages, regardless of whether that user is a member
	// of the namespace. Typically, this is used by an enterprise customer in
	// configuring a set of "well-known" namespaces.
	PUBLICNAMESPACES []string `json:"PUBLIC_NAMESPACES,omitempty"`

	// If recaptcha is enabled, the secret key for the Recaptcha service
	RECAPTCHASECRETKEY interface{} `json:"RECAPTCHA_SECRET_KEY,omitempty"`

	// If recaptcha is enabled, the site key for the Recaptcha service
	RECAPTCHASITEKEY interface{} `json:"RECAPTCHA_SITE_KEY,omitempty"`

	// The state of the registry.
	REGISTRYSTATE *QuayConfigSchemaREGISTRYSTATE `json:"REGISTRY_STATE,omitempty"`

	// If specified, the long-form title for the registry. Defaults to `Red Hat Quay`.
	REGISTRYTITLE *string `json:"REGISTRY_TITLE,omitempty"`

	// If specified, the short-form title for the registry. Defaults to `Red Hat
	// Quay`.
	REGISTRYTITLESHORT *string `json:"REGISTRY_TITLE_SHORT,omitempty"`

	// The number of seconds between checking for repository mirror candidates.
	// Defaults to 30.
	REPOMIRRORINTERVAL *float64 `json:"REPO_MIRROR_INTERVAL,omitempty"`

	// Replaces the SERVER_HOSTNAME as the destination for mirroring. Defaults to
	// unset
	REPOMIRRORSERVERHOSTNAME *string `json:"REPO_MIRROR_SERVER_HOSTNAME,omitempty"`

	// Require HTTPS and verify certificates of Quay registry during mirror. Defaults
	// to True
	REPOMIRRORTLSVERIFY *bool `json:"REPO_MIRROR_TLS_VERIFY,omitempty"`

	// Maximum number of pages the user can paginate in search before they are
	// limited. Defaults to 10
	SEARCHMAXRESULTPAGECOUNT *float64 `json:"SEARCH_MAX_RESULT_PAGE_COUNT,omitempty"`

	// Number of results returned per page by search page. Defaults to 10
	SEARCHRESULTSPERPAGE *float64 `json:"SEARCH_RESULTS_PER_PAGE,omitempty"`

	// The endpoint for the V2 security scanner
	SECURITYSCANNERENDPOINT *string `json:"SECURITY_SCANNER_ENDPOINT,omitempty"`

	// The number of seconds between indexing intervals in the security scanner.
	// Defaults to 30.
	SECURITYSCANNERINDEXINGINTERVAL *float64 `json:"SECURITY_SCANNER_INDEXING_INTERVAL,omitempty"`

	// The endpoint for the V4 security scanner
	SECURITYSCANNERV4ENDPOINT interface{} `json:"SECURITY_SCANNER_V4_ENDPOINT,omitempty"`

	// The URL at which Quay is accessible, without the scheme.
	SERVERHOSTNAME string `json:"SERVER_HOSTNAME"`

	// Whether the `secure` property should be set on session cookies. Defaults to
	// False. Recommended to be True for all installations using SSL.
	SESSIONCOOKIESECURE *bool `json:"SESSION_COOKIE_SECURE,omitempty"`

	// If specified, the nginx-defined list of SSL ciphers to enabled and disabled
	SSLCIPHERS []QuayConfigSchemaSSLCIPHERSElem `json:"SSL_CIPHERS,omitempty"`

	// If specified, the nginx-defined list of SSL protocols to enabled and disabled
	SSLPROTOCOLS []QuayConfigSchemaSSLPROTOCOLSElem `json:"SSL_PROTOCOLS,omitempty"`

	// If not None, the number of successive failures that can occur before a build
	// trigger is automatically disabled. Defaults to 100.
	SUCCESSIVETRIGGERFAILUREDISABLETHRESHOLD interface{} `json:"SUCCESSIVE_TRIGGER_FAILURE_DISABLE_THRESHOLD,omitempty"`

	// If not None, the number of successive internal errors that can occur before a
	// build trigger is automatically disabled. Defaults to 5.
	SUCCESSIVETRIGGERINTERNALERRORDISABLETHRESHOLD interface{} `json:"SUCCESSIVE_TRIGGER_INTERNAL_ERROR_DISABLE_THRESHOLD,omitempty"`

	// Quay usernames of those users to be granted superuser privileges
	SUPERUSERS []string `json:"SUPER_USERS,omitempty"`

	// The options that users can select for expiration of tags in their namespace (if
	// enabled)
	TAGEXPIRATIONOPTIONS []string `json:"TAG_EXPIRATION_OPTIONS"`

	// If team syncing is enabled for a team, how often to check its membership and
	// resync if necessary (Default: 30m)
	TEAMRESYNCSTALETIME *string `json:"TEAM_RESYNC_STALE_TIME,omitempty"`

	// ID of the storage engine in which to place user-uploaded files
	USERFILESLOCATION *string `json:"USERFILES_LOCATION,omitempty"`

	// Path under storage in which to place user-uploaded files
	USERFILESPATH *string `json:"USERFILES_PATH,omitempty"`

	// Connection information for Redis for user event handling
	USEREVENTSREDIS QuayConfigSchemaUSEREVENTSREDIS `json:"USER_EVENTS_REDIS"`

	// The length of time a token for recovering a user accounts is valid. Defaults to
	// 30m.
	USERRECOVERYTOKENLIFETIME *string `json:"USER_RECOVERY_TOKEN_LIFETIME,omitempty"`

	// The array of namespace names that support V1 push if FEATURE_RESTRICTED_V1_PUSH
	// is set to true.
	V1PUSHWHITELIST []interface{} `json:"V1_PUSH_WHITELIST,omitempty"`

	// The number of results returned per page in V2 registry APIs
	V2PAGINATIONSIZE *float64 `json:"V2_PAGINATION_SIZE,omitempty"`

	// The set of hostnames to disallow from webhooks when validating, beyond
	// localhost
	WEBHOOKHOSTNAMEBLACKLIST []interface{} `json:"WEBHOOK_HOSTNAME_BLACKLIST,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchemaAUTHENTICATIONTYPE) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuayConfigSchemaAUTHENTICATIONTYPE {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuayConfigSchemaAUTHENTICATIONTYPE, v)
	}
	*j = QuayConfigSchemaAUTHENTICATIONTYPE(v)
	return nil
}

const QuayConfigSchemaAUTHENTICATIONTYPEDatabase QuayConfigSchemaAUTHENTICATIONTYPE = "Database"
const QuayConfigSchemaAUTHENTICATIONTYPELDAP QuayConfigSchemaAUTHENTICATIONTYPE = "LDAP"
const QuayConfigSchemaAUTHENTICATIONTYPEJWT QuayConfigSchemaAUTHENTICATIONTYPE = "JWT"
const QuayConfigSchemaAUTHENTICATIONTYPEKeystone QuayConfigSchemaAUTHENTICATIONTYPE = "Keystone"
const QuayConfigSchemaAUTHENTICATIONTYPEOIDC QuayConfigSchemaAUTHENTICATIONTYPE = "OIDC"

type QuayConfigSchemaAUTHENTICATIONTYPE string

type QuayConfigSchemaAVATARKIND string

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchemaUSEREVENTSREDIS) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["host"]; !ok || v == nil {
		return fmt.Errorf("field host: required")
	}
	type Plain QuayConfigSchemaUSEREVENTSREDIS
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = QuayConfigSchemaUSEREVENTSREDIS(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchemaAVATARKIND) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuayConfigSchemaAVATARKIND {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuayConfigSchemaAVATARKIND, v)
	}
	*j = QuayConfigSchemaAVATARKIND(v)
	return nil
}

const QuayConfigSchemaAVATARKINDLocal QuayConfigSchemaAVATARKIND = "local"
const QuayConfigSchemaAVATARKINDGravatar QuayConfigSchemaAVATARKIND = "gravatar"

// Connection information for Redis for build logs caching
type QuayConfigSchemaBUILDLOGSREDIS struct {
	// The hostname at which Redis is accessible
	Host string `json:"host"`

	// The password to connect to the Redis instance
	Password *string `json:"password,omitempty"`

	// The port at which Redis is accessible
	Port *float64 `json:"port,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchemaBUILDLOGSREDIS) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["host"]; !ok || v == nil {
		return fmt.Errorf("field host: required")
	}
	type Plain QuayConfigSchemaBUILDLOGSREDIS
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = QuayConfigSchemaBUILDLOGSREDIS(plain)
	return nil
}

// SSL connection configuration
type QuayConfigSchemaDBCONNECTIONARGSSsl struct {
	// *Absolute container path* to the CA certificate to use for SSL connections
	Ca string `json:"ca"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchemaDBCONNECTIONARGSSsl) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ca"]; !ok || v == nil {
		return fmt.Errorf("field ca: required")
	}
	type Plain QuayConfigSchemaDBCONNECTIONARGSSsl
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = QuayConfigSchemaDBCONNECTIONARGSSsl(plain)
	return nil
}

// If specified, connection arguments for the database such as timeouts and SSL.
type QuayConfigSchemaDBCONNECTIONARGS struct {
	// Whether to use auto-rollback connections. Should *ALWAYS* be `true`
	Autorollback bool `json:"autorollback"`

	// SSL connection configuration
	Ssl *QuayConfigSchemaDBCONNECTIONARGSSsl `json:"ssl,omitempty"`

	// Whether to use thread-local connections. Should *ALWAYS* be `true`
	Threadlocals bool `json:"threadlocals"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchemaDBCONNECTIONARGS) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["autorollback"]; !ok || v == nil {
		return fmt.Errorf("field autorollback: required")
	}
	if v, ok := raw["threadlocals"]; !ok || v == nil {
		return fmt.Errorf("field threadlocals: required")
	}
	type Plain QuayConfigSchemaDBCONNECTIONARGS
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = QuayConfigSchemaDBCONNECTIONARGS(plain)
	return nil
}

// Configuration for storage engine(s) to use in Quay. Each key is a unique ID for
// a storage engine, with the value being a tuple of the type and  configuration
// for that engine.
type QuayConfigSchemaDISTRIBUTEDSTORAGECONFIG map[string]interface{}

type QuayConfigSchemaLOGSMODEL string

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchemaSSLPROTOCOLSElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuayConfigSchemaSSLPROTOCOLSElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuayConfigSchemaSSLPROTOCOLSElem, v)
	}
	*j = QuayConfigSchemaSSLPROTOCOLSElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchemaLOGSMODEL) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuayConfigSchemaLOGSMODEL {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuayConfigSchemaLOGSMODEL, v)
	}
	*j = QuayConfigSchemaLOGSMODEL(v)
	return nil
}

const QuayConfigSchemaLOGSMODELDatabase QuayConfigSchemaLOGSMODEL = "database"

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchemaSSLCIPHERSElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuayConfigSchemaSSLCIPHERSElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuayConfigSchemaSSLCIPHERSElem, v)
	}
	*j = QuayConfigSchemaSSLCIPHERSElem(v)
	return nil
}

const QuayConfigSchemaLOGSMODELCONFIGProducerKafka QuayConfigSchemaLOGSMODELCONFIGProducer = "kafka"

// Elasticsearch's index settings
type QuayConfigSchemaLOGSMODELCONFIGElasticsearchConfigIndexSettings map[string]interface{}

// Elasticsearch cluster configuration
type QuayConfigSchemaLOGSMODELCONFIGElasticsearchConfig struct {
	// Elasticsearch user (or IAM key for AWS ES)
	AccessKey *string `json:"access_key,omitempty"`

	// Amazon web service region
	AwsRegion *string `json:"aws_region,omitempty"`

	// Elasticsearch cluster endpoint
	Host *string `json:"host,omitempty"`

	// Elasticsearch's index prefix
	IndexPrefix *string `json:"index_prefix,omitempty"`

	// Elasticsearch's index settings
	IndexSettings QuayConfigSchemaLOGSMODELCONFIGElasticsearchConfigIndexSettings `json:"index_settings,omitempty"`

	// Elasticsearch cluster endpoint port
	Port *float64 `json:"port,omitempty"`

	// Elasticsearch password (or IAM secret for AWS ES)
	SecretKey *string `json:"secret_key,omitempty"`

	// Use ssl for Elasticsearch. Defaults to True
	UseSsl *bool `json:"use_ssl,omitempty"`
}

// Kafka cluster configuration
type QuayConfigSchemaLOGSMODELCONFIGKafkaConfig struct {
	// List of Kafka brokers to bootstrap the client from
	BootstrapServers []string `json:"bootstrap_servers,omitempty"`

	// Max number of seconds to block during a `send()`, either because the buffer is
	// full or metadata unavailable
	MaxBlockSeconds *float64 `json:"max_block_seconds,omitempty"`

	// Kafka topic to publish log entries to
	Topic *string `json:"topic,omitempty"`
}

// AWS Kinesis Stream configuration
type QuayConfigSchemaLOGSMODELCONFIGKinesisStreamConfig struct {
	// AWS access key
	AwsAccessKey *string `json:"aws_access_key,omitempty"`

	// AWS region
	AwsRegion *string `json:"aws_region,omitempty"`

	// AWS secret key
	AwsSecretKey *string `json:"aws_secret_key,omitempty"`

	// Number of seconds before timeout when attempting to make a connection
	ConnectTimeout *float64 `json:"connect_timeout,omitempty"`

	// The maximum number of connections to keep in a connection pool
	MaxPoolConnections *float64 `json:"max_pool_connections,omitempty"`

	// Number of seconds before timeout when reading from a connection
	ReadTimeout *float64 `json:"read_timeout,omitempty"`

	// Max number of attempts made on a single request
	Retries *float64 `json:"retries,omitempty"`

	// Kinesis stream to send action logs to
	StreamName *string `json:"stream_name,omitempty"`
}

type QuayConfigSchemaLOGSMODELCONFIGProducer string

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchemaREGISTRYSTATE) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuayConfigSchemaREGISTRYSTATE {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuayConfigSchemaREGISTRYSTATE, v)
	}
	*j = QuayConfigSchemaREGISTRYSTATE(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchemaLOGSMODELCONFIGProducer) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuayConfigSchemaLOGSMODELCONFIGProducer {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuayConfigSchemaLOGSMODELCONFIGProducer, v)
	}
	*j = QuayConfigSchemaLOGSMODELCONFIGProducer(v)
	return nil
}

const QuayConfigSchemaAUTHENTICATIONTYPEAppToken QuayConfigSchemaAUTHENTICATIONTYPE = "AppToken"
const QuayConfigSchemaLOGSMODELCONFIGProducerElasticsearch QuayConfigSchemaLOGSMODELCONFIGProducer = "elasticsearch"
const QuayConfigSchemaLOGSMODELCONFIGProducerKinesisStream QuayConfigSchemaLOGSMODELCONFIGProducer = "kinesis_stream"

// Logs model config for action logs
type QuayConfigSchemaLOGSMODELCONFIG struct {
	// Elasticsearch cluster configuration
	ElasticsearchConfig *QuayConfigSchemaLOGSMODELCONFIGElasticsearchConfig `json:"elasticsearch_config,omitempty"`

	// Kafka cluster configuration
	KafkaConfig *QuayConfigSchemaLOGSMODELCONFIGKafkaConfig `json:"kafka_config,omitempty"`

	// AWS Kinesis Stream configuration
	KinesisStreamConfig *QuayConfigSchemaLOGSMODELCONFIGKinesisStreamConfig `json:"kinesis_stream_config,omitempty"`

	// Logs producer if logging to Elasticsearch
	Producer *QuayConfigSchemaLOGSMODELCONFIGProducer `json:"producer,omitempty"`
}

const QuayConfigSchemaLOGSMODELElasticsearch QuayConfigSchemaLOGSMODEL = "elasticsearch"
const QuayConfigSchemaLOGSMODELTransitionReadsBothWritesEs QuayConfigSchemaLOGSMODEL = "transition_reads_both_writes_es"

type QuayConfigSchemaPREFERREDURLSCHEME string

const QuayConfigSchemaPREFERREDURLSCHEMEHttp QuayConfigSchemaPREFERREDURLSCHEME = "http"
const QuayConfigSchemaPREFERREDURLSCHEMEHttps QuayConfigSchemaPREFERREDURLSCHEME = "https"

type QuayConfigSchemaREGISTRYSTATE string

const QuayConfigSchemaREGISTRYSTATENormal QuayConfigSchemaREGISTRYSTATE = "normal"
const QuayConfigSchemaREGISTRYSTATEReadonly QuayConfigSchemaREGISTRYSTATE = "readonly"

type QuayConfigSchemaSSLCIPHERSElem string

const QuayConfigSchemaSSLCIPHERSElemA3DES QuayConfigSchemaSSLCIPHERSElem = "3DES"
const QuayConfigSchemaSSLCIPHERSElemADH QuayConfigSchemaSSLCIPHERSElem = "aDH"
const QuayConfigSchemaSSLCIPHERSElemADH QuayConfigSchemaSSLCIPHERSElem = "ADH"
const QuayConfigSchemaSSLCIPHERSElemADSS QuayConfigSchemaSSLCIPHERSElem = "aDSS"
const QuayConfigSchemaSSLCIPHERSElemAECDH QuayConfigSchemaSSLCIPHERSElem = "AECDH"
const QuayConfigSchemaSSLCIPHERSElemAECDH QuayConfigSchemaSSLCIPHERSElem = "aECDH"
const QuayConfigSchemaSSLCIPHERSElemAECDSA QuayConfigSchemaSSLCIPHERSElem = "aECDSA"
const QuayConfigSchemaSSLCIPHERSElemAES QuayConfigSchemaSSLCIPHERSElem = "AES"
const QuayConfigSchemaSSLCIPHERSElemAES128 QuayConfigSchemaSSLCIPHERSElem = "AES128"
const QuayConfigSchemaSSLCIPHERSElemAES256 QuayConfigSchemaSSLCIPHERSElem = "AES256"
const QuayConfigSchemaSSLCIPHERSElemAESGCM QuayConfigSchemaSSLCIPHERSElem = "AESGCM"
const QuayConfigSchemaSSLCIPHERSElemAFZA QuayConfigSchemaSSLCIPHERSElem = "aFZA"
const QuayConfigSchemaSSLCIPHERSElemAGOST QuayConfigSchemaSSLCIPHERSElem = "aGOST"
const QuayConfigSchemaSSLCIPHERSElemAGOST01 QuayConfigSchemaSSLCIPHERSElem = "aGOST01"
const QuayConfigSchemaSSLCIPHERSElemAGOST94 QuayConfigSchemaSSLCIPHERSElem = "aGOST94"
const QuayConfigSchemaSSLCIPHERSElemALL QuayConfigSchemaSSLCIPHERSElem = "ALL"
const QuayConfigSchemaSSLCIPHERSElemANULL QuayConfigSchemaSSLCIPHERSElem = "aNULL"
const QuayConfigSchemaSSLCIPHERSElemARSA QuayConfigSchemaSSLCIPHERSElem = "aRSA"
const QuayConfigSchemaSSLCIPHERSElemCAMELLIA QuayConfigSchemaSSLCIPHERSElem = "CAMELLIA"
const QuayConfigSchemaSSLCIPHERSElemCAMELLIA128 QuayConfigSchemaSSLCIPHERSElem = "CAMELLIA128"
const QuayConfigSchemaSSLCIPHERSElemCAMELLIA256 QuayConfigSchemaSSLCIPHERSElem = "CAMELLIA256"
const QuayConfigSchemaSSLCIPHERSElemCOMPLEMENTOFALL QuayConfigSchemaSSLCIPHERSElem = "COMPLEMENTOFALL"
const QuayConfigSchemaSSLCIPHERSElemCOMPLEMENTOFDEFAULT QuayConfigSchemaSSLCIPHERSElem = "COMPLEMENTOFDEFAULT"
const QuayConfigSchemaSSLCIPHERSElemDEFAULT QuayConfigSchemaSSLCIPHERSElem = "DEFAULT"
const QuayConfigSchemaSSLCIPHERSElemDES QuayConfigSchemaSSLCIPHERSElem = "DES"
const QuayConfigSchemaSSLCIPHERSElemDH QuayConfigSchemaSSLCIPHERSElem = "DH"
const QuayConfigSchemaSSLCIPHERSElemDHE QuayConfigSchemaSSLCIPHERSElem = "DHE"
const QuayConfigSchemaSSLCIPHERSElemDSS QuayConfigSchemaSSLCIPHERSElem = "DSS"
const QuayConfigSchemaSSLCIPHERSElemECDH QuayConfigSchemaSSLCIPHERSElem = "ECDH"
const QuayConfigSchemaSSLCIPHERSElemECDHE QuayConfigSchemaSSLCIPHERSElem = "ECDHE"
const QuayConfigSchemaSSLCIPHERSElemECDSA QuayConfigSchemaSSLCIPHERSElem = "ECDSA"
const QuayConfigSchemaSSLCIPHERSElemEDH QuayConfigSchemaSSLCIPHERSElem = "EDH"
const QuayConfigSchemaSSLCIPHERSElemEECDH QuayConfigSchemaSSLCIPHERSElem = "EECDH"
const QuayConfigSchemaSSLCIPHERSElemEFZA QuayConfigSchemaSSLCIPHERSElem = "eFZA"
const QuayConfigSchemaSSLCIPHERSElemENULL QuayConfigSchemaSSLCIPHERSElem = "eNULL"
const QuayConfigSchemaSSLCIPHERSElemEXP QuayConfigSchemaSSLCIPHERSElem = "EXP"
const QuayConfigSchemaSSLCIPHERSElemEXPORT QuayConfigSchemaSSLCIPHERSElem = "EXPORT"
const QuayConfigSchemaSSLCIPHERSElemEXPORT40 QuayConfigSchemaSSLCIPHERSElem = "EXPORT40"
const QuayConfigSchemaSSLCIPHERSElemEXPORT56 QuayConfigSchemaSSLCIPHERSElem = "EXPORT56"
const QuayConfigSchemaSSLCIPHERSElemFZA QuayConfigSchemaSSLCIPHERSElem = "FZA"
const QuayConfigSchemaSSLCIPHERSElemGOST89MAC QuayConfigSchemaSSLCIPHERSElem = "GOST89MAC"
const QuayConfigSchemaSSLCIPHERSElemGOST94 QuayConfigSchemaSSLCIPHERSElem = "GOST94"
const QuayConfigSchemaSSLCIPHERSElemHIGH QuayConfigSchemaSSLCIPHERSElem = "HIGH"
const QuayConfigSchemaSSLCIPHERSElemIDEA QuayConfigSchemaSSLCIPHERSElem = "IDEA"
const QuayConfigSchemaSSLCIPHERSElemKDH QuayConfigSchemaSSLCIPHERSElem = "kDH"
const QuayConfigSchemaSSLCIPHERSElemKDHd QuayConfigSchemaSSLCIPHERSElem = "kDHd"
const QuayConfigSchemaSSLCIPHERSElemKDHr QuayConfigSchemaSSLCIPHERSElem = "kDHr"
const QuayConfigSchemaSSLCIPHERSElemKECDH QuayConfigSchemaSSLCIPHERSElem = "kECDH"
const QuayConfigSchemaSSLCIPHERSElemKECDHE QuayConfigSchemaSSLCIPHERSElem = "kECDHE"
const QuayConfigSchemaSSLCIPHERSElemKECDHe QuayConfigSchemaSSLCIPHERSElem = "kECDHe"
const QuayConfigSchemaSSLCIPHERSElemKECDHr QuayConfigSchemaSSLCIPHERSElem = "kECDHr"
const QuayConfigSchemaSSLCIPHERSElemKEECDH QuayConfigSchemaSSLCIPHERSElem = "kEECDH"
const QuayConfigSchemaSSLCIPHERSElemKFZA QuayConfigSchemaSSLCIPHERSElem = "kFZA"
const QuayConfigSchemaSSLCIPHERSElemKGOST QuayConfigSchemaSSLCIPHERSElem = "kGOST"
const QuayConfigSchemaSSLCIPHERSElemKRSA QuayConfigSchemaSSLCIPHERSElem = "kRSA"
const QuayConfigSchemaSSLCIPHERSElemLOW QuayConfigSchemaSSLCIPHERSElem = "LOW"
const QuayConfigSchemaSSLCIPHERSElemMD5 QuayConfigSchemaSSLCIPHERSElem = "MD5"
const QuayConfigSchemaSSLCIPHERSElemMEDIUM QuayConfigSchemaSSLCIPHERSElem = "MEDIUM"
const QuayConfigSchemaSSLCIPHERSElemNULL QuayConfigSchemaSSLCIPHERSElem = "NULL"
const QuayConfigSchemaSSLCIPHERSElemPSK QuayConfigSchemaSSLCIPHERSElem = "PSK"
const QuayConfigSchemaSSLCIPHERSElemRC2 QuayConfigSchemaSSLCIPHERSElem = "RC2"
const QuayConfigSchemaSSLCIPHERSElemRC4 QuayConfigSchemaSSLCIPHERSElem = "RC4"
const QuayConfigSchemaSSLCIPHERSElemRSA QuayConfigSchemaSSLCIPHERSElem = "RSA"
const QuayConfigSchemaSSLCIPHERSElemSEED QuayConfigSchemaSSLCIPHERSElem = "SEED"
const QuayConfigSchemaSSLCIPHERSElemSHA QuayConfigSchemaSSLCIPHERSElem = "SHA"
const QuayConfigSchemaSSLCIPHERSElemSHA1 QuayConfigSchemaSSLCIPHERSElem = "SHA1"
const QuayConfigSchemaSSLCIPHERSElemSHA256 QuayConfigSchemaSSLCIPHERSElem = "SHA256"
const QuayConfigSchemaSSLCIPHERSElemSHA384 QuayConfigSchemaSSLCIPHERSElem = "SHA384"
const QuayConfigSchemaSSLCIPHERSElemSSLv2 QuayConfigSchemaSSLCIPHERSElem = "SSLv2"
const QuayConfigSchemaSSLCIPHERSElemSSLv3 QuayConfigSchemaSSLCIPHERSElem = "SSLv3"
const QuayConfigSchemaSSLCIPHERSElemSUITEB128 QuayConfigSchemaSSLCIPHERSElem = "SUITEB128"
const QuayConfigSchemaSSLCIPHERSElemSUITEB128ONLY QuayConfigSchemaSSLCIPHERSElem = "SUITEB128ONLY"
const QuayConfigSchemaSSLCIPHERSElemSUITEB192 QuayConfigSchemaSSLCIPHERSElem = "SUITEB192"
const QuayConfigSchemaSSLCIPHERSElemTLSv1 QuayConfigSchemaSSLCIPHERSElem = "TLSv1"
const QuayConfigSchemaSSLCIPHERSElemTLSv12 QuayConfigSchemaSSLCIPHERSElem = "TLSv1.2"

type QuayConfigSchemaSSLPROTOCOLSElem string

const QuayConfigSchemaSSLPROTOCOLSElemSSLv2 QuayConfigSchemaSSLPROTOCOLSElem = "SSLv2"
const QuayConfigSchemaSSLPROTOCOLSElemSSLv3 QuayConfigSchemaSSLPROTOCOLSElem = "SSLv3"
const QuayConfigSchemaSSLPROTOCOLSElemTLSv1 QuayConfigSchemaSSLPROTOCOLSElem = "TLSv1"
const QuayConfigSchemaSSLPROTOCOLSElemTLSv11 QuayConfigSchemaSSLPROTOCOLSElem = "TLSv1.1"
const QuayConfigSchemaSSLPROTOCOLSElemTLSv12 QuayConfigSchemaSSLPROTOCOLSElem = "TLSv1.2"
const QuayConfigSchemaSSLPROTOCOLSElemTLSv13 QuayConfigSchemaSSLPROTOCOLSElem = "TLSv1.3"

// Connection information for Redis for user event handling
type QuayConfigSchemaUSEREVENTSREDIS struct {
	// The hostname at which Redis is accessible
	Host string `json:"host"`

	// The password to connect to the Redis instance
	Password *string `json:"password,omitempty"`

	// The port at which Redis is accessible
	Port *float64 `json:"port,omitempty"`
}

var enumValues_QuayConfigSchemaAUTHENTICATIONTYPE = []interface{}{
	"Database",
	"LDAP",
	"JWT",
	"Keystone",
	"OIDC",
	"AppToken",
}
var enumValues_QuayConfigSchemaAVATARKIND = []interface{}{
	"local",
	"gravatar",
}
var enumValues_QuayConfigSchemaLOGSMODEL = []interface{}{
	"database",
	"transition_reads_both_writes_es",
	"elasticsearch",
}
var enumValues_QuayConfigSchemaLOGSMODELCONFIGProducer = []interface{}{
	"kafka",
	"elasticsearch",
	"kinesis_stream",
}
var enumValues_QuayConfigSchemaPREFERREDURLSCHEME = []interface{}{
	"http",
	"https",
}
var enumValues_QuayConfigSchemaREGISTRYSTATE = []interface{}{
	"normal",
	"readonly",
}
var enumValues_QuayConfigSchemaSSLCIPHERSElem = []interface{}{
	"DEFAULT",
	"COMPLEMENTOFDEFAULT",
	"ALL",
	"COMPLEMENTOFALL",
	"HIGH",
	"MEDIUM",
	"LOW",
	"EXP",
	"EXPORT",
	"EXPORT40",
	"EXPORT56",
	"eNULL",
	"NULL",
	"aNULL",
	"kRSA",
	"RSA",
	"kDHr",
	"kDHd",
	"kDH",
	"DHE",
	"EDH",
	"ADH",
	"DH",
	"kECDHr",
	"kECDHe",
	"kECDH",
	"kECDHE",
	"kEECDH",
	"ECDHE",
	"EECDH",
	"AECDH",
	"ECDH",
	"aRSA",
	"aDSS",
	"DSS",
	"aDH",
	"aECDH",
	"aECDSA",
	"ECDSA",
	"kFZA",
	"aFZA",
	"eFZA",
	"FZA",
	"TLSv1.2",
	"TLSv1",
	"SSLv3",
	"SSLv2",
	"AES128",
	"AES256",
	"AES",
	"AESGCM",
	"CAMELLIA128",
	"CAMELLIA256",
	"CAMELLIA",
	"3DES",
	"DES",
	"RC4",
	"RC2",
	"IDEA",
	"SEED",
	"MD5",
	"SHA1",
	"SHA",
	"SHA256",
	"SHA384",
	"aGOST",
	"aGOST01",
	"aGOST94",
	"kGOST",
	"GOST94",
	"GOST89MAC",
	"PSK",
	"SUITEB128",
	"SUITEB128ONLY",
	"SUITEB192",
}
var enumValues_QuayConfigSchemaSSLPROTOCOLSElem = []interface{}{
	"SSLv2",
	"SSLv3",
	"TLSv1",
	"TLSv1.1",
	"TLSv1.2",
	"TLSv1.3",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuayConfigSchema) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["AUTHENTICATION_TYPE"]; !ok || v == nil {
		return fmt.Errorf("field AUTHENTICATION_TYPE: required")
	}
	if v, ok := raw["BUILDLOGS_REDIS"]; !ok || v == nil {
		return fmt.Errorf("field BUILDLOGS_REDIS: required")
	}
	if v, ok := raw["DB_URI"]; !ok || v == nil {
		return fmt.Errorf("field DB_URI: required")
	}
	if v, ok := raw["DEFAULT_TAG_EXPIRATION"]; !ok || v == nil {
		return fmt.Errorf("field DEFAULT_TAG_EXPIRATION: required")
	}
	if v, ok := raw["DISTRIBUTED_STORAGE_CONFIG"]; !ok || v == nil {
		return fmt.Errorf("field DISTRIBUTED_STORAGE_CONFIG: required")
	}
	if v, ok := raw["DISTRIBUTED_STORAGE_PREFERENCE"]; !ok || v == nil {
		return fmt.Errorf("field DISTRIBUTED_STORAGE_PREFERENCE: required")
	}
	if v, ok := raw["PREFERRED_URL_SCHEME"]; !ok || v == nil {
		return fmt.Errorf("field PREFERRED_URL_SCHEME: required")
	}
	if v, ok := raw["SERVER_HOSTNAME"]; !ok || v == nil {
		return fmt.Errorf("field SERVER_HOSTNAME: required")
	}
	if v, ok := raw["TAG_EXPIRATION_OPTIONS"]; !ok || v == nil {
		return fmt.Errorf("field TAG_EXPIRATION_OPTIONS: required")
	}
	if v, ok := raw["USER_EVENTS_REDIS"]; !ok || v == nil {
		return fmt.Errorf("field USER_EVENTS_REDIS: required")
	}
	type Plain QuayConfigSchema
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = QuayConfigSchema(plain)
	return nil
}
