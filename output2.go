// Code generated by schema-generate. DO NOT EDIT.

package main

import (
    "errors"
    "bytes"
    "encoding/json"
)

// BITBUCKETTRIGGERCONFIG_object Configuration for using BitBucket for build triggers
type BITBUCKETTRIGGERCONFIG_object struct {

  // The registered consumer key (client ID) for this Quay instance
  CONSUMERKEY string `json:"CONSUMER_KEY"`

  // The registered consumer secret (client secret) for this Quay instance
  CONSUMERSECRET string `json:"CONSUMER_SECRET"`
}

// BRANDING_object Custom branding for logos and URLs in the Quay UI
type BRANDING_object struct {

  // Logo for UI footer
  FooterImg string `json:"footer_img,omitempty"`

  // Link for footer image
  FooterUrl string `json:"footer_url,omitempty"`

  // Main logo image URL
  Logo string `json:"logo"`
}

// BUILDLOGSREDIS Connection information for Redis for build logs caching
type BUILDLOGSREDIS struct {

  // The hostname at which Redis is accessible
  Host string `json:"host"`

  // The password to connect to the Redis instance
  Password string `json:"password,omitempty"`

  // The port at which Redis is accessible
  Port float64 `json:"port,omitempty"`
}

// DBCONNECTIONARGS If specified, connection arguments for the database such as timeouts and SSL.
type DBCONNECTIONARGS struct {

  // Whether to use auto-rollback connections. Should *ALWAYS* be `true`
  Autorollback bool `json:"autorollback"`

  // SSL connection configuration
  Ssl *Ssl `json:"ssl,omitempty"`

  // Whether to use thread-local connections. Should *ALWAYS* be `true`
  Threadlocals bool `json:"threadlocals"`
}

// DISTRIBUTEDSTORAGECONFIG Configuration for storage engine(s) to use in Quay. Each key is a unique ID for a storage engine, with the value being a tuple of the type and  configuration for that engine.
type DISTRIBUTEDSTORAGECONFIG struct {
}

// ElasticsearchConfig Elasticsearch cluster configuration
type ElasticsearchConfig struct {

  // Elasticsearch user (or IAM key for AWS ES)
  AccessKey string `json:"access_key,omitempty"`

  // Amazon web service region
  AwsRegion string `json:"aws_region,omitempty"`

  // Elasticsearch cluster endpoint
  Host string `json:"host,omitempty"`

  // Elasticsearch's index prefix
  IndexPrefix string `json:"index_prefix,omitempty"`

  // Elasticsearch's index settings
  IndexSettings *IndexSettings `json:"index_settings,omitempty"`

  // Elasticsearch cluster endpoint port
  Port float64 `json:"port,omitempty"`

  // Elasticsearch password (or IAM secret for AWS ES)
  SecretKey string `json:"secret_key,omitempty"`

  // Use ssl for Elasticsearch. Defaults to True
  UseSsl bool `json:"use_ssl,omitempty"`
}

// GITHUBLOGINCONFIG_object Configuration for using GitHub (Enterprise) as an external login provider
type GITHUBLOGINCONFIG_object struct {

  // The names of the GitHub (Enterprise) organizations whitelisted to work with the ORG_RESTRICT option
  ALLOWEDORGANIZATIONS []string `json:"ALLOWED_ORGANIZATIONS,omitempty"`

  // The endpoint of the GitHub (Enterprise) API to use. Must be overridden for github.com
  APIENDPOINT string `json:"API_ENDPOINT,omitempty"`

  // The registered client ID for this Quay instance; cannot be shared with GITHUB_TRIGGER_CONFIG
  CLIENTID string `json:"CLIENT_ID"`

  // The registered client secret for this Quay instance
  CLIENTSECRET string `json:"CLIENT_SECRET"`

  // The endpoint of the GitHub (Enterprise) being hit
  GITHUBENDPOINT string `json:"GITHUB_ENDPOINT,omitempty"`

  // If true, only users within the organization whitelist can login using this provider
  ORGRESTRICT bool `json:"ORG_RESTRICT,omitempty"`
}

// GITHUBTRIGGERCONFIG_object Configuration for using GitHub (Enterprise) for build triggers
type GITHUBTRIGGERCONFIG_object struct {

  // The endpoint of the GitHub (Enterprise) API to use. Must be overridden for github.com
  APIENDPOINT string `json:"API_ENDPOINT,omitempty"`

  // The registered client ID for this Quay instance; cannot be shared with GITHUB_LOGIN_CONFIG
  CLIENTID string `json:"CLIENT_ID"`

  // The registered client secret for this Quay instance
  CLIENTSECRET string `json:"CLIENT_SECRET"`

  // The endpoint of the GitHub (Enterprise) being hit
  GITHUBENDPOINT string `json:"GITHUB_ENDPOINT"`
}

// GITLABTRIGGERCONFIG_object Configuration for using Gitlab (Enterprise) for external authentication
type GITLABTRIGGERCONFIG_object struct {

  // The registered client ID for this Quay instance
  CLIENTID string `json:"CLIENT_ID"`

  // The registered client secret for this Quay instance
  CLIENTSECRET string `json:"CLIENT_SECRET"`

  // The endpoint at which Gitlab(Enterprise) is running
  GITLABENDPOINT string `json:"GITLAB_ENDPOINT"`
}

// GOOGLELOGINCONFIG_object Configuration for using Google for external authentication
type GOOGLELOGINCONFIG_object struct {

  // The registered client ID for this Quay instance
  CLIENTID string `json:"CLIENT_ID"`

  // The registered client secret for this Quay instance
  CLIENTSECRET string `json:"CLIENT_SECRET"`
}

// IndexSettings Elasticsearch's index settings
type IndexSettings struct {
}

// KafkaConfig Kafka cluster configuration
type KafkaConfig struct {

  // List of Kafka brokers to bootstrap the client from
  BootstrapServers []string `json:"bootstrap_servers,omitempty"`

  // Max number of seconds to block during a `send()`, either because the buffer is full or metadata unavailable
  MaxBlockSeconds float64 `json:"max_block_seconds,omitempty"`

  // Kafka topic to publish log entries to
  Topic string `json:"topic,omitempty"`
}

// KinesisStreamConfig AWS Kinesis Stream configuration
type KinesisStreamConfig struct {

  // AWS access key
  AwsAccessKey string `json:"aws_access_key,omitempty"`

  // AWS region
  AwsRegion string `json:"aws_region,omitempty"`

  // AWS secret key
  AwsSecretKey string `json:"aws_secret_key,omitempty"`

  // Number of seconds before timeout when attempting to make a connection
  ConnectTimeout float64 `json:"connect_timeout,omitempty"`

  // The maximum number of connections to keep in a connection pool
  MaxPoolConnections float64 `json:"max_pool_connections,omitempty"`

  // Number of seconds before timeout when reading from a connection
  ReadTimeout float64 `json:"read_timeout,omitempty"`

  // Max number of attempts made on a single request
  Retries float64 `json:"retries,omitempty"`

  // Kinesis stream to send action logs to
  StreamName string `json:"stream_name,omitempty"`
}

// LOGSMODELCONFIG Logs model config for action logs
type LOGSMODELCONFIG struct {

  // Elasticsearch cluster configuration
  ElasticsearchConfig *ElasticsearchConfig `json:"elasticsearch_config,omitempty"`

  // Kafka cluster configuration
  KafkaConfig *KafkaConfig `json:"kafka_config,omitempty"`

  // AWS Kinesis Stream configuration
  KinesisStreamConfig *KinesisStreamConfig `json:"kinesis_stream_config,omitempty"`

  // Logs producer if logging to Elasticsearch
  Producer string `json:"producer,omitempty"`
}

// Root Schema for Quay configuration
type Root struct {

  // If action log archiving is enabled, the storage engine in which to place the archived data.
  ACTIONLOGARCHIVELOCATION string `json:"ACTION_LOG_ARCHIVE_LOCATION,omitempty"`

  // If action log archiving is enabled, the path in storage in which to place the archived data.
  ACTIONLOGARCHIVEPATH string `json:"ACTION_LOG_ARCHIVE_PATH,omitempty"`

  // If action log archiving is enabled, the time interval after which to archive data.
  ACTIONLOGROTATIONTHRESHOLD string `json:"ACTION_LOG_ROTATION_THRESHOLD,omitempty"`

  // If true, pulls in which the pull audit log entry cannot be written will still succeed. Useful if the database can fallback into a read-only state and it is desired for pulls to continue during that time. Defaults to False.
  ALLOWPULLSWITHOUTSTRICTLOGGING bool `json:"ALLOW_PULLS_WITHOUT_STRICT_LOGGING,omitempty"`

  // The expiration for external app tokens. Defaults to None.
  APPSPECIFICTOKENEXPIRATION interface{} `json:"APP_SPECIFIC_TOKEN_EXPIRATION,omitempty"`

  // The authentication engine to use for credential authentication.
  AUTHENTICATIONTYPE string `json:"AUTHENTICATION_TYPE"`

  // The types of avatars to display, either generated inline (local) or Gravatar (gravatar)
  AVATARKIND string `json:"AVATAR_KIND,omitempty"`

  // Configuration for using BitBucket for build triggers
  BITBUCKETTRIGGERCONFIG interface{} `json:"BITBUCKET_TRIGGER_CONFIG,omitempty"`

  // The array of email-address domains that is used if FEATURE_BLACKLISTED_EMAILS is set to true.
  BLACKLISTEDEMAILDOMAINS []interface{} `json:"BLACKLISTED_EMAIL_DOMAINS,omitempty"`

  // The Docker CLI versions to which Quay will respond that V2 is *unsupported*. Defaults to `<1.6.0`
  BLACKLISTV2SPEC string `json:"BLACKLIST_V2_SPEC,omitempty"`

  // Custom branding for logos and URLs in the Quay UI
  BRANDING interface{} `json:"BRANDING,omitempty"`

  // If enabled, only API calls marked as being made by an XHR will be allowed from browsers. Defaults to True.
  BROWSERAPICALLSXHRONLY bool `json:"BROWSER_API_CALLS_XHR_ONLY,omitempty"`

  // Connection information for Redis for build logs caching
  BUILDLOGSREDIS *BUILDLOGSREDIS `json:"BUILDLOGS_REDIS"`

  // If specified, contact information to display on the contact page. If only a single piece of contact information is specified, the contact footer will link directly.
  CONTACTINFO []interface{} `json:"CONTACT_INFO,omitempty"`

  // If specified, connection arguments for the database such as timeouts and SSL.
  DBCONNECTIONARGS *DBCONNECTIONARGS `json:"DB_CONNECTION_ARGS,omitempty"`

  // The URI at which to access the database, including any credentials.
  DBURI string `json:"DB_URI"`

  // If not None, the default maximum number of builds that can be queued in a namespace.
  DEFAULTNAMESPACEMAXIMUMBUILDCOUNT interface{} `json:"DEFAULT_NAMESPACE_MAXIMUM_BUILD_COUNT,omitempty"`

  // The default, configurable tag expiration time for time machine. Defaults to `2w`.
  DEFAULTTAGEXPIRATION string `json:"DEFAULT_TAG_EXPIRATION"`

  // A list of client IDs of *Quay-managed* applications that are allowed to perform direct OAuth approval without user approval.
  DIRECTOAUTHCLIENTIDWHITELIST []string `json:"DIRECT_OAUTH_CLIENTID_WHITELIST,omitempty"`

  // Configuration for storage engine(s) to use in Quay. Each key is a unique ID for a storage engine, with the value being a tuple of the type and  configuration for that engine.
  DISTRIBUTEDSTORAGECONFIG *DISTRIBUTEDSTORAGECONFIG `json:"DISTRIBUTED_STORAGE_CONFIG"`

  // The list of storage engine(s) (by ID in DISTRIBUTED_STORAGE_CONFIG) whose images should be fully replicated, by default, to all other storage engines.
  DISTRIBUTEDSTORAGEDEFAULTLOCATIONS []string `json:"DISTRIBUTED_STORAGE_DEFAULT_LOCATIONS,omitempty"`

  // The preferred storage engine(s) (by ID in DISTRIBUTED_STORAGE_CONFIG) to use. A preferred engine means it is first checked for pullig and images are pushed to it.
  DISTRIBUTEDSTORAGEPREFERENCE []string `json:"DISTRIBUTED_STORAGE_PREFERENCE"`

  // Root URL for documentation links
  DOCUMENTATIONROOT string `json:"DOCUMENTATION_ROOT,omitempty"`

  // If specified, a secret that can be given to health endpoints to see full debug info whennot authenticated as a superuser
  ENABLEHEALTHDEBUGSECRET interface{} `json:"ENABLE_HEALTH_DEBUG_SECRET,omitempty"`

  // Duration of time expired external app tokens will remain before being garbage collected. Defaults to 1d.
  EXPIREDAPPSPECIFICTOKENGC interface{} `json:"EXPIRED_APP_SPECIFIC_TOKEN_GC,omitempty"`

  // If TLS is supported, but terminated at a layer before Quay, must be true.
  EXTERNALTLSTERMINATION bool `json:"EXTERNAL_TLS_TERMINATION,omitempty"`

  // Whether to enable conversion to ACIs. Defaults to False
  FEATUREACICONVERSION bool `json:"FEATURE_ACI_CONVERSION,omitempty"`

  // Whether or not to rotate old action logs to storage. Defaults to False
  FEATUREACTIONLOGROTATION bool `json:"FEATURE_ACTION_LOG_ROTATION,omitempty"`

  // Whether the v2/ endpoint is visible. Defaults to True
  FEATUREADVERTISEV2 bool `json:"FEATURE_ADVERTISE_V2,omitempty"`

  // Whether to allow retrieval of aggregated log counts. Defaults to True
  FEATUREAGGREGATEDLOGCOUNTRETRIEVAL bool `json:"FEATURE_AGGREGATED_LOG_COUNT_RETRIEVAL,omitempty"`

  //  Whether to allow anonymous users to browse and pull public repositories. Defaults to True
  FEATUREANONYMOUSACCESS bool `json:"FEATURE_ANONYMOUS_ACCESS,omitempty"`

  // Whether to enable support for App repositories. Defaults to False
  FEATUREAPPREGISTRY bool `json:"FEATURE_APP_REGISTRY,omitempty"`

  // If enabled, users can create tokens for use by the Docker CLI. Defaults to True
  FEATUREAPPSPECIFICTOKENS bool `json:"FEATURE_APP_SPECIFIC_TOKENS,omitempty"`

  // Whether to support Bitbucket build triggers. Defaults to False
  FEATUREBITBUCKETBUILD bool `json:"FEATURE_BITBUCKET_BUILD,omitempty"`

  // If set to true, no new User accounts may be created if their email domain is blacklisted.
  FEATUREBLACKLISTEDEMAILS bool `json:"FEATURE_BLACKLISTED_EMAILS,omitempty"`

  // Whether to support Dockerfile build. Defaults to True
  FEATUREBUILDSUPPORT bool `json:"FEATURE_BUILD_SUPPORT,omitempty"`

  // Whether users and organizations are allowed to change the tag expiration for tags in their namespace. Defaults to True.
  FEATURECHANGETAGEXPIRATION bool `json:"FEATURE_CHANGE_TAG_EXPIRATION,omitempty"`

  // Whether users can directly login to the UI. Defaults to True
  FEATUREDIRECTLOGIN bool `json:"FEATURE_DIRECT_LOGIN,omitempty"`

  // Whether garbage collection of repositories is enabled. Defaults to True
  FEATUREGARBAGECOLLECTION bool `json:"FEATURE_GARBAGE_COLLECTION,omitempty"`

  // Whether to support GitHub build triggers. Defaults to False
  FEATUREGITHUBBUILD bool `json:"FEATURE_GITHUB_BUILD,omitempty"`

  // Whether GitHub login is supported. Defaults to False
  FEATUREGITHUBLOGIN bool `json:"FEATURE_GITHUB_LOGIN,omitempty"`

  // Whether to support GitLab build triggers. Defaults to False
  FEATUREGITLABBUILD bool `json:"FEATURE_GITLAB_BUILD,omitempty"`

  // Whether Google login is supported. Defaults to False
  FEATUREGOOGLELOGIN bool `json:"FEATURE_GOOGLE_LOGIN,omitempty"`

  // Whether users being created must be invited by another user. Defaults to False
  FEATUREINVITEONLYUSERCREATION bool `json:"FEATURE_INVITE_ONLY_USER_CREATION,omitempty"`

  // Whether to allow for "namespace-less" repositories when pulling and pushing from Docker. Defaults to True
  FEATURELIBRARYSUPPORT bool `json:"FEATURE_LIBRARY_SUPPORT,omitempty"`

  // Whether to allow exporting of action logs. Defaults to True
  FEATURELOGEXPORT bool `json:"FEATURE_LOG_EXPORT,omitempty"`

  // Whether emails are enabled. Defaults to True
  FEATUREMAILING bool `json:"FEATURE_MAILING,omitempty"`

  // If enabled, non-superusers can setup syncing on teams to backing LDAP or Keystone. Defaults To False.
  FEATURENONSUPERUSERTEAMSYNCINGSETUP bool `json:"FEATURE_NONSUPERUSER_TEAM_SYNCING_SETUP,omitempty"`

  // If set to true, autocompletion will apply to partial usernames. Defaults to True
  FEATUREPARTIALUSERAUTOCOMPLETE bool `json:"FEATURE_PARTIAL_USER_AUTOCOMPLETE,omitempty"`

  // Whether sessions are permanent. Defaults to True
  FEATUREPERMANENTSESSIONS bool `json:"FEATURE_PERMANENT_SESSIONS,omitempty"`

  // Whether to proxy all direct download URLs in storage via the registry nginx. Defaults to False
  FEATUREPROXYSTORAGE bool `json:"FEATURE_PROXY_STORAGE,omitempty"`

  // If set to true, the _catalog endpoint returns public repositories. Otherwise, only private repositories can be returned. Defaults to False
  FEATUREPUBLICCATALOG bool `json:"FEATURE_PUBLIC_CATALOG,omitempty"`

  // Whether to enable rate limits on API and registry endpoints. Defaults to False
  FEATURERATELIMITS bool `json:"FEATURE_RATE_LIMITS,omitempty"`

  // If set to true, build logs may be read by those with read access to the repo, rather than only write access or admin access. Defaults to False
  FEATUREREADERBUILDLOGS bool `json:"FEATURE_READER_BUILD_LOGS,omitempty"`

  // Whether to App repositories are read-only. Defaults to False
  FEATUREREADONLYAPPREGISTRY bool `json:"FEATURE_READONLY_APP_REGISTRY,omitempty"`

  // Whether Recaptcha is necessary for user login and recovery. Defaults to False
  FEATURERECAPTCHA bool `json:"FEATURE_RECAPTCHA,omitempty"`

  // Whether to enable support for repository mirroring. Defaults to False
  FEATUREREPOMIRROR bool `json:"FEATURE_REPO_MIRROR,omitempty"`

  // Whether non-encrypted passwords (as opposed to encrypted tokens) can be used for basic auth. Defaults to False
  FEATUREREQUIREENCRYPTEDBASICAUTH bool `json:"FEATURE_REQUIRE_ENCRYPTED_BASIC_AUTH,omitempty"`

  // Whether to require invitations when adding a user to a team. Defaults to True
  FEATUREREQUIRETEAMINVITE bool `json:"FEATURE_REQUIRE_TEAM_INVITE,omitempty"`

  // If set to true, only namespaces listed in V1_PUSH_WHITELIST support V1 push. Defaults to True
  FEATURERESTRICTEDV1PUSH bool `json:"FEATURE_RESTRICTED_V1_PUSH,omitempty"`

  // If the security scanner is enabled, whether to turn of/off security notificaitons. Defaults to False
  FEATURESECURITYNOTIFICATIONS bool `json:"FEATURE_SECURITY_NOTIFICATIONS,omitempty"`

  // Whether to turn of/off the security scanner. Defaults to False
  FEATURESECURITYSCANNER bool `json:"FEATURE_SECURITY_SCANNER,omitempty"`

  // Whether to automatically replicate between storage engines. Defaults to False
  FEATURESTORAGEREPLICATION bool `json:"FEATURE_STORAGE_REPLICATION,omitempty"`

  // Whether super users are supported. Defaults to True
  FEATURESUPERUSERS bool `json:"FEATURE_SUPER_USERS,omitempty"`

  // Whether to allow for team membership to be synced from a backing group in the authentication engine (LDAP or Keystone)
  FEATURETEAMSYNCING bool `json:"FEATURE_TEAM_SYNCING,omitempty"`

  // Whether users can be created (by non-super users). Defaults to True
  FEATUREUSERCREATION bool `json:"FEATURE_USER_CREATION,omitempty"`

  // Whether to record the last time a user was accessed. Defaults to True
  FEATUREUSERLASTACCESSED bool `json:"FEATURE_USER_LAST_ACCESSED,omitempty"`

  // If set to true, users will have access to audit logs for their namespace. Defaults to False
  FEATUREUSERLOGACCESS bool `json:"FEATURE_USER_LOG_ACCESS,omitempty"`

  // Whether to collect and support user metadata. Defaults to False
  FEATUREUSERMETADATA bool `json:"FEATURE_USER_METADATA,omitempty"`

  // If set to true, users can confirm their generated usernames. Defaults to True
  FEATUREUSERNAMECONFIRMATION bool `json:"FEATURE_USERNAME_CONFIRMATION,omitempty"`

  // If set to true, users can rename their own namespace. Defaults to False
  FEATUREUSERRENAME bool `json:"FEATURE_USER_RENAME,omitempty"`

  // The time after which a fresh login requires users to reenter their password
  FRESHLOGINTIMEOUT string `json:"FRESH_LOGIN_TIMEOUT,omitempty"`

  // Configuration for using GitHub (Enterprise) as an external login provider
  GITHUBLOGINCONFIG interface{} `json:"GITHUB_LOGIN_CONFIG,omitempty"`

  // Configuration for using GitHub (Enterprise) for build triggers
  GITHUBTRIGGERCONFIG interface{} `json:"GITHUB_TRIGGER_CONFIG,omitempty"`

  // Configuration for using Gitlab (Enterprise) for external authentication
  GITLABTRIGGERCONFIG interface{} `json:"GITLAB_TRIGGER_CONFIG,omitempty"`

  // Configuration for using Google for external authentication
  GOOGLELOGINCONFIG interface{} `json:"GOOGLE_LOGIN_CONFIG,omitempty"`

  // The configured health check.
  HEALTHCHECKER interface{} `json:"HEALTH_CHECKER,omitempty"`

  // If builds are enabled, the storage engine in which to place the archived build logs.
  LOGARCHIVELOCATION string `json:"LOG_ARCHIVE_LOCATION,omitempty"`

  // If builds are enabled, the path in storage in which to place the archived build logs.
  LOGARCHIVEPATH string `json:"LOG_ARCHIVE_PATH,omitempty"`

  // Logs model for action logs
  LOGSMODEL string `json:"LOGS_MODEL,omitempty"`

  // Logs model config for action logs
  LOGSMODELCONFIG *LOGSMODELCONFIG `json:"LOGS_MODEL_CONFIG,omitempty"`

  // If specified, the e-mail address used as the `from` when Quay sends e-mails. If none, defaults to `support@quay.io`.
  MAILDEFAULTSENDER interface{} `json:"MAIL_DEFAULT_SENDER,omitempty"`

  // The SMTP password to use when sending e-mails.
  MAILPASSWORD interface{} `json:"MAIL_PASSWORD,omitempty"`

  // The SMTP port to use. If not specified, defaults to 587.
  MAILPORT float64 `json:"MAIL_PORT,omitempty"`

  // The SMTP server to use for sending e-mails. Only required if FEATURE_MAILING is set to true.
  MAILSERVER string `json:"MAIL_SERVER,omitempty"`

  // The SMTP username to use when sending e-mails.
  MAILUSERNAME interface{} `json:"MAIL_USERNAME,omitempty"`

  // If specified, whether to use TLS for sending e-mails.
  MAILUSETLS bool `json:"MAIL_USE_TLS,omitempty"`

  // Maximum allowed size of an image layer. Defaults to 20G
  MAXIMUMLAYERSIZE string `json:"MAXIMUM_LAYER_SIZE,omitempty"`

  // The URL scheme to use when hitting Quay. If Quay is behind SSL *at all*, this *must* be `https`
  PREFERREDURLSCHEME string `json:"PREFERRED_URL_SCHEME"`

  // The prefix applied to all exposed Prometheus metrics. Defaults to `quay`
  PROMETHEUSNAMESPACE string `json:"PROMETHEUS_NAMESPACE,omitempty"`

  // If a namespace is defined in the public namespace list, then it will appear on *all* user's repository list pages, regardless of whether that user is a member of the namespace. Typically, this is used by an enterprise customer in configuring a set of "well-known" namespaces.
  PUBLICNAMESPACES []string `json:"PUBLIC_NAMESPACES,omitempty"`

  // If recaptcha is enabled, the secret key for the Recaptcha service
  RECAPTCHASECRETKEY interface{} `json:"RECAPTCHA_SECRET_KEY,omitempty"`

  // If recaptcha is enabled, the site key for the Recaptcha service
  RECAPTCHASITEKEY interface{} `json:"RECAPTCHA_SITE_KEY,omitempty"`

  // The state of the registry.
  REGISTRYSTATE string `json:"REGISTRY_STATE,omitempty"`

  // If specified, the long-form title for the registry. Defaults to `Red Hat Quay`.
  REGISTRYTITLE string `json:"REGISTRY_TITLE,omitempty"`

  // If specified, the short-form title for the registry. Defaults to `Red Hat Quay`.
  REGISTRYTITLESHORT string `json:"REGISTRY_TITLE_SHORT,omitempty"`

  // The number of seconds between checking for repository mirror candidates. Defaults to 30.
  REPOMIRRORINTERVAL float64 `json:"REPO_MIRROR_INTERVAL,omitempty"`

  // Replaces the SERVER_HOSTNAME as the destination for mirroring. Defaults to unset
  REPOMIRRORSERVERHOSTNAME string `json:"REPO_MIRROR_SERVER_HOSTNAME,omitempty"`

  // Require HTTPS and verify certificates of Quay registry during mirror. Defaults to True
  REPOMIRRORTLSVERIFY bool `json:"REPO_MIRROR_TLS_VERIFY,omitempty"`

  // Maximum number of pages the user can paginate in search before they are limited. Defaults to 10
  SEARCHMAXRESULTPAGECOUNT float64 `json:"SEARCH_MAX_RESULT_PAGE_COUNT,omitempty"`

  // Number of results returned per page by search page. Defaults to 10
  SEARCHRESULTSPERPAGE float64 `json:"SEARCH_RESULTS_PER_PAGE,omitempty"`

  // The endpoint for the V2 security scanner
  SECURITYSCANNERENDPOINT string `json:"SECURITY_SCANNER_ENDPOINT,omitempty"`

  // The number of seconds between indexing intervals in the security scanner. Defaults to 30.
  SECURITYSCANNERINDEXINGINTERVAL float64 `json:"SECURITY_SCANNER_INDEXING_INTERVAL,omitempty"`

  // The endpoint for the V4 security scanner
  SECURITYSCANNERV4ENDPOINT interface{} `json:"SECURITY_SCANNER_V4_ENDPOINT,omitempty"`

  // The URL at which Quay is accessible, without the scheme.
  SERVERHOSTNAME string `json:"SERVER_HOSTNAME"`

  // Whether the `secure` property should be set on session cookies. Defaults to False. Recommended to be True for all installations using SSL.
  SESSIONCOOKIESECURE bool `json:"SESSION_COOKIE_SECURE,omitempty"`

  // If specified, the nginx-defined list of SSL ciphers to enabled and disabled
  SSLCIPHERS []interface{} `json:"SSL_CIPHERS,omitempty"`

  // If specified, the nginx-defined list of SSL protocols to enabled and disabled
  SSLPROTOCOLS []interface{} `json:"SSL_PROTOCOLS,omitempty"`

  // If not None, the number of successive failures that can occur before a build trigger is automatically disabled. Defaults to 100.
  SUCCESSIVETRIGGERFAILUREDISABLETHRESHOLD interface{} `json:"SUCCESSIVE_TRIGGER_FAILURE_DISABLE_THRESHOLD,omitempty"`

  // If not None, the number of successive internal errors that can occur before a build trigger is automatically disabled. Defaults to 5.
  SUCCESSIVETRIGGERINTERNALERRORDISABLETHRESHOLD interface{} `json:"SUCCESSIVE_TRIGGER_INTERNAL_ERROR_DISABLE_THRESHOLD,omitempty"`

  // Quay usernames of those users to be granted superuser privileges
  SUPERUSERS []string `json:"SUPER_USERS,omitempty"`

  // The options that users can select for expiration of tags in their namespace (if enabled)
  TAGEXPIRATIONOPTIONS []string `json:"TAG_EXPIRATION_OPTIONS"`

  // If team syncing is enabled for a team, how often to check its membership and resync if necessary (Default: 30m)
  TEAMRESYNCSTALETIME string `json:"TEAM_RESYNC_STALE_TIME,omitempty"`

  // Connection information for Redis for user event handling
  USEREVENTSREDIS *USEREVENTSREDIS `json:"USER_EVENTS_REDIS"`

  // ID of the storage engine in which to place user-uploaded files
  USERFILESLOCATION string `json:"USERFILES_LOCATION,omitempty"`

  // Path under storage in which to place user-uploaded files
  USERFILESPATH string `json:"USERFILES_PATH,omitempty"`

  // The length of time a token for recovering a user accounts is valid. Defaults to 30m.
  USERRECOVERYTOKENLIFETIME string `json:"USER_RECOVERY_TOKEN_LIFETIME,omitempty"`

  // The array of namespace names that support V1 push if FEATURE_RESTRICTED_V1_PUSH is set to true.
  V1PUSHWHITELIST []interface{} `json:"V1_PUSH_WHITELIST,omitempty"`

  // The number of results returned per page in V2 registry APIs
  V2PAGINATIONSIZE float64 `json:"V2_PAGINATION_SIZE,omitempty"`

  // The set of hostnames to disallow from webhooks when validating, beyond localhost
  WEBHOOKHOSTNAMEBLACKLIST []interface{} `json:"WEBHOOK_HOSTNAME_BLACKLIST,omitempty"`
}

// Ssl SSL connection configuration
type Ssl struct {

  // *Absolute container path* to the CA certificate to use for SSL connections
  Ca string `json:"ca"`
}

// USEREVENTSREDIS Connection information for Redis for user event handling
type USEREVENTSREDIS struct {

  // The hostname at which Redis is accessible
  Host string `json:"host"`

  // The password to connect to the Redis instance
  Password string `json:"password,omitempty"`

  // The port at which Redis is accessible
  Port float64 `json:"port,omitempty"`
}

func (strct *BITBUCKETTRIGGERCONFIG_object) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CONSUMERKEY" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CONSUMER_KEY" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CONSUMER_KEY\": ")
	if tmp, err := json.Marshal(strct.CONSUMERKEY); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CONSUMERSECRET" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CONSUMER_SECRET" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CONSUMER_SECRET\": ")
	if tmp, err := json.Marshal(strct.CONSUMERSECRET); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BITBUCKETTRIGGERCONFIG_object) UnmarshalJSON(b []byte) error {
    CONSUMER_KEYReceived := false
    CONSUMER_SECRETReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CONSUMER_KEY":
            if err := json.Unmarshal([]byte(v), &strct.CONSUMERKEY); err != nil {
                return err
             }
            CONSUMER_KEYReceived = true
        case "CONSUMER_SECRET":
            if err := json.Unmarshal([]byte(v), &strct.CONSUMERSECRET); err != nil {
                return err
             }
            CONSUMER_SECRETReceived = true
        }
    }
    // check if CONSUMER_KEY (a required property) was received
    if !CONSUMER_KEYReceived {
        return errors.New("\"CONSUMER_KEY\" is required but was not present")
    }
    // check if CONSUMER_SECRET (a required property) was received
    if !CONSUMER_SECRETReceived {
        return errors.New("\"CONSUMER_SECRET\" is required but was not present")
    }
    return nil
}

func (strct *BRANDING_object) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "footer_img" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"footer_img\": ")
	if tmp, err := json.Marshal(strct.FooterImg); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "footer_url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"footer_url\": ")
	if tmp, err := json.Marshal(strct.FooterUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Logo" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "logo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"logo\": ")
	if tmp, err := json.Marshal(strct.Logo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BRANDING_object) UnmarshalJSON(b []byte) error {
    logoReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "footer_img":
            if err := json.Unmarshal([]byte(v), &strct.FooterImg); err != nil {
                return err
             }
        case "footer_url":
            if err := json.Unmarshal([]byte(v), &strct.FooterUrl); err != nil {
                return err
             }
        case "logo":
            if err := json.Unmarshal([]byte(v), &strct.Logo); err != nil {
                return err
             }
            logoReceived = true
        }
    }
    // check if logo (a required property) was received
    if !logoReceived {
        return errors.New("\"logo\" is required but was not present")
    }
    return nil
}

func (strct *BUILDLOGSREDIS) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "password" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"password\": ")
	if tmp, err := json.Marshal(strct.Password); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BUILDLOGSREDIS) UnmarshalJSON(b []byte) error {
    hostReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            hostReceived = true
        case "password":
            if err := json.Unmarshal([]byte(v), &strct.Password); err != nil {
                return err
             }
        case "port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        }
    }
    // check if host (a required property) was received
    if !hostReceived {
        return errors.New("\"host\" is required but was not present")
    }
    return nil
}

func (strct *DBCONNECTIONARGS) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Autorollback" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "autorollback" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"autorollback\": ")
	if tmp, err := json.Marshal(strct.Autorollback); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ssl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ssl\": ")
	if tmp, err := json.Marshal(strct.Ssl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Threadlocals" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "threadlocals" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"threadlocals\": ")
	if tmp, err := json.Marshal(strct.Threadlocals); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DBCONNECTIONARGS) UnmarshalJSON(b []byte) error {
    autorollbackReceived := false
    threadlocalsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "autorollback":
            if err := json.Unmarshal([]byte(v), &strct.Autorollback); err != nil {
                return err
             }
            autorollbackReceived = true
        case "ssl":
            if err := json.Unmarshal([]byte(v), &strct.Ssl); err != nil {
                return err
             }
        case "threadlocals":
            if err := json.Unmarshal([]byte(v), &strct.Threadlocals); err != nil {
                return err
             }
            threadlocalsReceived = true
        }
    }
    // check if autorollback (a required property) was received
    if !autorollbackReceived {
        return errors.New("\"autorollback\" is required but was not present")
    }
    // check if threadlocals (a required property) was received
    if !threadlocalsReceived {
        return errors.New("\"threadlocals\" is required but was not present")
    }
    return nil
}

func (strct *GITHUBLOGINCONFIG_object) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ALLOWED_ORGANIZATIONS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ALLOWED_ORGANIZATIONS\": ")
	if tmp, err := json.Marshal(strct.ALLOWEDORGANIZATIONS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "API_ENDPOINT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"API_ENDPOINT\": ")
	if tmp, err := json.Marshal(strct.APIENDPOINT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CLIENTID" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CLIENT_ID" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CLIENT_ID\": ")
	if tmp, err := json.Marshal(strct.CLIENTID); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CLIENTSECRET" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CLIENT_SECRET" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CLIENT_SECRET\": ")
	if tmp, err := json.Marshal(strct.CLIENTSECRET); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GITHUB_ENDPOINT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GITHUB_ENDPOINT\": ")
	if tmp, err := json.Marshal(strct.GITHUBENDPOINT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ORG_RESTRICT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ORG_RESTRICT\": ")
	if tmp, err := json.Marshal(strct.ORGRESTRICT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GITHUBLOGINCONFIG_object) UnmarshalJSON(b []byte) error {
    CLIENT_IDReceived := false
    CLIENT_SECRETReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ALLOWED_ORGANIZATIONS":
            if err := json.Unmarshal([]byte(v), &strct.ALLOWEDORGANIZATIONS); err != nil {
                return err
             }
        case "API_ENDPOINT":
            if err := json.Unmarshal([]byte(v), &strct.APIENDPOINT); err != nil {
                return err
             }
        case "CLIENT_ID":
            if err := json.Unmarshal([]byte(v), &strct.CLIENTID); err != nil {
                return err
             }
            CLIENT_IDReceived = true
        case "CLIENT_SECRET":
            if err := json.Unmarshal([]byte(v), &strct.CLIENTSECRET); err != nil {
                return err
             }
            CLIENT_SECRETReceived = true
        case "GITHUB_ENDPOINT":
            if err := json.Unmarshal([]byte(v), &strct.GITHUBENDPOINT); err != nil {
                return err
             }
        case "ORG_RESTRICT":
            if err := json.Unmarshal([]byte(v), &strct.ORGRESTRICT); err != nil {
                return err
             }
        }
    }
    // check if CLIENT_ID (a required property) was received
    if !CLIENT_IDReceived {
        return errors.New("\"CLIENT_ID\" is required but was not present")
    }
    // check if CLIENT_SECRET (a required property) was received
    if !CLIENT_SECRETReceived {
        return errors.New("\"CLIENT_SECRET\" is required but was not present")
    }
    return nil
}

func (strct *GITHUBTRIGGERCONFIG_object) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "API_ENDPOINT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"API_ENDPOINT\": ")
	if tmp, err := json.Marshal(strct.APIENDPOINT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CLIENTID" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CLIENT_ID" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CLIENT_ID\": ")
	if tmp, err := json.Marshal(strct.CLIENTID); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CLIENTSECRET" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CLIENT_SECRET" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CLIENT_SECRET\": ")
	if tmp, err := json.Marshal(strct.CLIENTSECRET); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "GITHUBENDPOINT" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "GITHUB_ENDPOINT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GITHUB_ENDPOINT\": ")
	if tmp, err := json.Marshal(strct.GITHUBENDPOINT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GITHUBTRIGGERCONFIG_object) UnmarshalJSON(b []byte) error {
    CLIENT_IDReceived := false
    CLIENT_SECRETReceived := false
    GITHUB_ENDPOINTReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "API_ENDPOINT":
            if err := json.Unmarshal([]byte(v), &strct.APIENDPOINT); err != nil {
                return err
             }
        case "CLIENT_ID":
            if err := json.Unmarshal([]byte(v), &strct.CLIENTID); err != nil {
                return err
             }
            CLIENT_IDReceived = true
        case "CLIENT_SECRET":
            if err := json.Unmarshal([]byte(v), &strct.CLIENTSECRET); err != nil {
                return err
             }
            CLIENT_SECRETReceived = true
        case "GITHUB_ENDPOINT":
            if err := json.Unmarshal([]byte(v), &strct.GITHUBENDPOINT); err != nil {
                return err
             }
            GITHUB_ENDPOINTReceived = true
        }
    }
    // check if CLIENT_ID (a required property) was received
    if !CLIENT_IDReceived {
        return errors.New("\"CLIENT_ID\" is required but was not present")
    }
    // check if CLIENT_SECRET (a required property) was received
    if !CLIENT_SECRETReceived {
        return errors.New("\"CLIENT_SECRET\" is required but was not present")
    }
    // check if GITHUB_ENDPOINT (a required property) was received
    if !GITHUB_ENDPOINTReceived {
        return errors.New("\"GITHUB_ENDPOINT\" is required but was not present")
    }
    return nil
}

func (strct *GITLABTRIGGERCONFIG_object) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CLIENTID" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CLIENT_ID" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CLIENT_ID\": ")
	if tmp, err := json.Marshal(strct.CLIENTID); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CLIENTSECRET" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CLIENT_SECRET" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CLIENT_SECRET\": ")
	if tmp, err := json.Marshal(strct.CLIENTSECRET); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "GITLABENDPOINT" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "GITLAB_ENDPOINT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GITLAB_ENDPOINT\": ")
	if tmp, err := json.Marshal(strct.GITLABENDPOINT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GITLABTRIGGERCONFIG_object) UnmarshalJSON(b []byte) error {
    CLIENT_IDReceived := false
    CLIENT_SECRETReceived := false
    GITLAB_ENDPOINTReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CLIENT_ID":
            if err := json.Unmarshal([]byte(v), &strct.CLIENTID); err != nil {
                return err
             }
            CLIENT_IDReceived = true
        case "CLIENT_SECRET":
            if err := json.Unmarshal([]byte(v), &strct.CLIENTSECRET); err != nil {
                return err
             }
            CLIENT_SECRETReceived = true
        case "GITLAB_ENDPOINT":
            if err := json.Unmarshal([]byte(v), &strct.GITLABENDPOINT); err != nil {
                return err
             }
            GITLAB_ENDPOINTReceived = true
        }
    }
    // check if CLIENT_ID (a required property) was received
    if !CLIENT_IDReceived {
        return errors.New("\"CLIENT_ID\" is required but was not present")
    }
    // check if CLIENT_SECRET (a required property) was received
    if !CLIENT_SECRETReceived {
        return errors.New("\"CLIENT_SECRET\" is required but was not present")
    }
    // check if GITLAB_ENDPOINT (a required property) was received
    if !GITLAB_ENDPOINTReceived {
        return errors.New("\"GITLAB_ENDPOINT\" is required but was not present")
    }
    return nil
}

func (strct *GOOGLELOGINCONFIG_object) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CLIENTID" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CLIENT_ID" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CLIENT_ID\": ")
	if tmp, err := json.Marshal(strct.CLIENTID); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CLIENTSECRET" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CLIENT_SECRET" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CLIENT_SECRET\": ")
	if tmp, err := json.Marshal(strct.CLIENTSECRET); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GOOGLELOGINCONFIG_object) UnmarshalJSON(b []byte) error {
    CLIENT_IDReceived := false
    CLIENT_SECRETReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CLIENT_ID":
            if err := json.Unmarshal([]byte(v), &strct.CLIENTID); err != nil {
                return err
             }
            CLIENT_IDReceived = true
        case "CLIENT_SECRET":
            if err := json.Unmarshal([]byte(v), &strct.CLIENTSECRET); err != nil {
                return err
             }
            CLIENT_SECRETReceived = true
        }
    }
    // check if CLIENT_ID (a required property) was received
    if !CLIENT_IDReceived {
        return errors.New("\"CLIENT_ID\" is required but was not present")
    }
    // check if CLIENT_SECRET (a required property) was received
    if !CLIENT_SECRETReceived {
        return errors.New("\"CLIENT_SECRET\" is required but was not present")
    }
    return nil
}

func (strct *Root) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ACTION_LOG_ARCHIVE_LOCATION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ACTION_LOG_ARCHIVE_LOCATION\": ")
	if tmp, err := json.Marshal(strct.ACTIONLOGARCHIVELOCATION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ACTION_LOG_ARCHIVE_PATH" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ACTION_LOG_ARCHIVE_PATH\": ")
	if tmp, err := json.Marshal(strct.ACTIONLOGARCHIVEPATH); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ACTION_LOG_ROTATION_THRESHOLD" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ACTION_LOG_ROTATION_THRESHOLD\": ")
	if tmp, err := json.Marshal(strct.ACTIONLOGROTATIONTHRESHOLD); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ALLOW_PULLS_WITHOUT_STRICT_LOGGING" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ALLOW_PULLS_WITHOUT_STRICT_LOGGING\": ")
	if tmp, err := json.Marshal(strct.ALLOWPULLSWITHOUTSTRICTLOGGING); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "APP_SPECIFIC_TOKEN_EXPIRATION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"APP_SPECIFIC_TOKEN_EXPIRATION\": ")
	if tmp, err := json.Marshal(strct.APPSPECIFICTOKENEXPIRATION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AUTHENTICATIONTYPE" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "AUTHENTICATION_TYPE" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AUTHENTICATION_TYPE\": ")
	if tmp, err := json.Marshal(strct.AUTHENTICATIONTYPE); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "AVATAR_KIND" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"AVATAR_KIND\": ")
	if tmp, err := json.Marshal(strct.AVATARKIND); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BITBUCKET_TRIGGER_CONFIG" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BITBUCKET_TRIGGER_CONFIG\": ")
	if tmp, err := json.Marshal(strct.BITBUCKETTRIGGERCONFIG); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BLACKLISTED_EMAIL_DOMAINS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BLACKLISTED_EMAIL_DOMAINS\": ")
	if tmp, err := json.Marshal(strct.BLACKLISTEDEMAILDOMAINS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BLACKLIST_V2_SPEC" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BLACKLIST_V2_SPEC\": ")
	if tmp, err := json.Marshal(strct.BLACKLISTV2SPEC); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BRANDING" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BRANDING\": ")
	if tmp, err := json.Marshal(strct.BRANDING); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "BROWSER_API_CALLS_XHR_ONLY" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BROWSER_API_CALLS_XHR_ONLY\": ")
	if tmp, err := json.Marshal(strct.BROWSERAPICALLSXHRONLY); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BUILDLOGSREDIS" field is required
    if strct.BUILDLOGSREDIS == nil {
        return nil, errors.New("BUILDLOGS_REDIS is a required field")
    }
    // Marshal the "BUILDLOGS_REDIS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"BUILDLOGS_REDIS\": ")
	if tmp, err := json.Marshal(strct.BUILDLOGSREDIS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "CONTACT_INFO" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CONTACT_INFO\": ")
	if tmp, err := json.Marshal(strct.CONTACTINFO); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DB_CONNECTION_ARGS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DB_CONNECTION_ARGS\": ")
	if tmp, err := json.Marshal(strct.DBCONNECTIONARGS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DBURI" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DB_URI" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DB_URI\": ")
	if tmp, err := json.Marshal(strct.DBURI); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DEFAULT_NAMESPACE_MAXIMUM_BUILD_COUNT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DEFAULT_NAMESPACE_MAXIMUM_BUILD_COUNT\": ")
	if tmp, err := json.Marshal(strct.DEFAULTNAMESPACEMAXIMUMBUILDCOUNT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DEFAULTTAGEXPIRATION" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DEFAULT_TAG_EXPIRATION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DEFAULT_TAG_EXPIRATION\": ")
	if tmp, err := json.Marshal(strct.DEFAULTTAGEXPIRATION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DIRECT_OAUTH_CLIENTID_WHITELIST" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DIRECT_OAUTH_CLIENTID_WHITELIST\": ")
	if tmp, err := json.Marshal(strct.DIRECTOAUTHCLIENTIDWHITELIST); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DISTRIBUTEDSTORAGECONFIG" field is required
    if strct.DISTRIBUTEDSTORAGECONFIG == nil {
        return nil, errors.New("DISTRIBUTED_STORAGE_CONFIG is a required field")
    }
    // Marshal the "DISTRIBUTED_STORAGE_CONFIG" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DISTRIBUTED_STORAGE_CONFIG\": ")
	if tmp, err := json.Marshal(strct.DISTRIBUTEDSTORAGECONFIG); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DISTRIBUTED_STORAGE_DEFAULT_LOCATIONS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DISTRIBUTED_STORAGE_DEFAULT_LOCATIONS\": ")
	if tmp, err := json.Marshal(strct.DISTRIBUTEDSTORAGEDEFAULTLOCATIONS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DISTRIBUTEDSTORAGEPREFERENCE" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "DISTRIBUTED_STORAGE_PREFERENCE" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DISTRIBUTED_STORAGE_PREFERENCE\": ")
	if tmp, err := json.Marshal(strct.DISTRIBUTEDSTORAGEPREFERENCE); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "DOCUMENTATION_ROOT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"DOCUMENTATION_ROOT\": ")
	if tmp, err := json.Marshal(strct.DOCUMENTATIONROOT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "ENABLE_HEALTH_DEBUG_SECRET" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ENABLE_HEALTH_DEBUG_SECRET\": ")
	if tmp, err := json.Marshal(strct.ENABLEHEALTHDEBUGSECRET); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EXPIRED_APP_SPECIFIC_TOKEN_GC" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EXPIRED_APP_SPECIFIC_TOKEN_GC\": ")
	if tmp, err := json.Marshal(strct.EXPIREDAPPSPECIFICTOKENGC); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "EXTERNAL_TLS_TERMINATION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"EXTERNAL_TLS_TERMINATION\": ")
	if tmp, err := json.Marshal(strct.EXTERNALTLSTERMINATION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_ACI_CONVERSION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_ACI_CONVERSION\": ")
	if tmp, err := json.Marshal(strct.FEATUREACICONVERSION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_ACTION_LOG_ROTATION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_ACTION_LOG_ROTATION\": ")
	if tmp, err := json.Marshal(strct.FEATUREACTIONLOGROTATION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_ADVERTISE_V2" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_ADVERTISE_V2\": ")
	if tmp, err := json.Marshal(strct.FEATUREADVERTISEV2); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_AGGREGATED_LOG_COUNT_RETRIEVAL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_AGGREGATED_LOG_COUNT_RETRIEVAL\": ")
	if tmp, err := json.Marshal(strct.FEATUREAGGREGATEDLOGCOUNTRETRIEVAL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_ANONYMOUS_ACCESS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_ANONYMOUS_ACCESS\": ")
	if tmp, err := json.Marshal(strct.FEATUREANONYMOUSACCESS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_APP_REGISTRY" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_APP_REGISTRY\": ")
	if tmp, err := json.Marshal(strct.FEATUREAPPREGISTRY); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_APP_SPECIFIC_TOKENS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_APP_SPECIFIC_TOKENS\": ")
	if tmp, err := json.Marshal(strct.FEATUREAPPSPECIFICTOKENS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_BITBUCKET_BUILD" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_BITBUCKET_BUILD\": ")
	if tmp, err := json.Marshal(strct.FEATUREBITBUCKETBUILD); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_BLACKLISTED_EMAILS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_BLACKLISTED_EMAILS\": ")
	if tmp, err := json.Marshal(strct.FEATUREBLACKLISTEDEMAILS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_BUILD_SUPPORT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_BUILD_SUPPORT\": ")
	if tmp, err := json.Marshal(strct.FEATUREBUILDSUPPORT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_CHANGE_TAG_EXPIRATION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_CHANGE_TAG_EXPIRATION\": ")
	if tmp, err := json.Marshal(strct.FEATURECHANGETAGEXPIRATION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_DIRECT_LOGIN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_DIRECT_LOGIN\": ")
	if tmp, err := json.Marshal(strct.FEATUREDIRECTLOGIN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_GARBAGE_COLLECTION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_GARBAGE_COLLECTION\": ")
	if tmp, err := json.Marshal(strct.FEATUREGARBAGECOLLECTION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_GITHUB_BUILD" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_GITHUB_BUILD\": ")
	if tmp, err := json.Marshal(strct.FEATUREGITHUBBUILD); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_GITHUB_LOGIN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_GITHUB_LOGIN\": ")
	if tmp, err := json.Marshal(strct.FEATUREGITHUBLOGIN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_GITLAB_BUILD" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_GITLAB_BUILD\": ")
	if tmp, err := json.Marshal(strct.FEATUREGITLABBUILD); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_GOOGLE_LOGIN" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_GOOGLE_LOGIN\": ")
	if tmp, err := json.Marshal(strct.FEATUREGOOGLELOGIN); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_INVITE_ONLY_USER_CREATION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_INVITE_ONLY_USER_CREATION\": ")
	if tmp, err := json.Marshal(strct.FEATUREINVITEONLYUSERCREATION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_LIBRARY_SUPPORT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_LIBRARY_SUPPORT\": ")
	if tmp, err := json.Marshal(strct.FEATURELIBRARYSUPPORT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_LOG_EXPORT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_LOG_EXPORT\": ")
	if tmp, err := json.Marshal(strct.FEATURELOGEXPORT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_MAILING" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_MAILING\": ")
	if tmp, err := json.Marshal(strct.FEATUREMAILING); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_NONSUPERUSER_TEAM_SYNCING_SETUP" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_NONSUPERUSER_TEAM_SYNCING_SETUP\": ")
	if tmp, err := json.Marshal(strct.FEATURENONSUPERUSERTEAMSYNCINGSETUP); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_PARTIAL_USER_AUTOCOMPLETE" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_PARTIAL_USER_AUTOCOMPLETE\": ")
	if tmp, err := json.Marshal(strct.FEATUREPARTIALUSERAUTOCOMPLETE); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_PERMANENT_SESSIONS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_PERMANENT_SESSIONS\": ")
	if tmp, err := json.Marshal(strct.FEATUREPERMANENTSESSIONS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_PROXY_STORAGE" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_PROXY_STORAGE\": ")
	if tmp, err := json.Marshal(strct.FEATUREPROXYSTORAGE); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_PUBLIC_CATALOG" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_PUBLIC_CATALOG\": ")
	if tmp, err := json.Marshal(strct.FEATUREPUBLICCATALOG); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_RATE_LIMITS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_RATE_LIMITS\": ")
	if tmp, err := json.Marshal(strct.FEATURERATELIMITS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_READER_BUILD_LOGS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_READER_BUILD_LOGS\": ")
	if tmp, err := json.Marshal(strct.FEATUREREADERBUILDLOGS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_READONLY_APP_REGISTRY" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_READONLY_APP_REGISTRY\": ")
	if tmp, err := json.Marshal(strct.FEATUREREADONLYAPPREGISTRY); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_RECAPTCHA" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_RECAPTCHA\": ")
	if tmp, err := json.Marshal(strct.FEATURERECAPTCHA); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_REPO_MIRROR" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_REPO_MIRROR\": ")
	if tmp, err := json.Marshal(strct.FEATUREREPOMIRROR); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_REQUIRE_ENCRYPTED_BASIC_AUTH" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_REQUIRE_ENCRYPTED_BASIC_AUTH\": ")
	if tmp, err := json.Marshal(strct.FEATUREREQUIREENCRYPTEDBASICAUTH); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_REQUIRE_TEAM_INVITE" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_REQUIRE_TEAM_INVITE\": ")
	if tmp, err := json.Marshal(strct.FEATUREREQUIRETEAMINVITE); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_RESTRICTED_V1_PUSH" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_RESTRICTED_V1_PUSH\": ")
	if tmp, err := json.Marshal(strct.FEATURERESTRICTEDV1PUSH); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_SECURITY_NOTIFICATIONS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_SECURITY_NOTIFICATIONS\": ")
	if tmp, err := json.Marshal(strct.FEATURESECURITYNOTIFICATIONS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_SECURITY_SCANNER" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_SECURITY_SCANNER\": ")
	if tmp, err := json.Marshal(strct.FEATURESECURITYSCANNER); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_STORAGE_REPLICATION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_STORAGE_REPLICATION\": ")
	if tmp, err := json.Marshal(strct.FEATURESTORAGEREPLICATION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_SUPER_USERS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_SUPER_USERS\": ")
	if tmp, err := json.Marshal(strct.FEATURESUPERUSERS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_TEAM_SYNCING" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_TEAM_SYNCING\": ")
	if tmp, err := json.Marshal(strct.FEATURETEAMSYNCING); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_USER_CREATION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_USER_CREATION\": ")
	if tmp, err := json.Marshal(strct.FEATUREUSERCREATION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_USER_LAST_ACCESSED" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_USER_LAST_ACCESSED\": ")
	if tmp, err := json.Marshal(strct.FEATUREUSERLASTACCESSED); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_USER_LOG_ACCESS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_USER_LOG_ACCESS\": ")
	if tmp, err := json.Marshal(strct.FEATUREUSERLOGACCESS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_USER_METADATA" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_USER_METADATA\": ")
	if tmp, err := json.Marshal(strct.FEATUREUSERMETADATA); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_USERNAME_CONFIRMATION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_USERNAME_CONFIRMATION\": ")
	if tmp, err := json.Marshal(strct.FEATUREUSERNAMECONFIRMATION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FEATURE_USER_RENAME" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FEATURE_USER_RENAME\": ")
	if tmp, err := json.Marshal(strct.FEATUREUSERRENAME); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "FRESH_LOGIN_TIMEOUT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"FRESH_LOGIN_TIMEOUT\": ")
	if tmp, err := json.Marshal(strct.FRESHLOGINTIMEOUT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GITHUB_LOGIN_CONFIG" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GITHUB_LOGIN_CONFIG\": ")
	if tmp, err := json.Marshal(strct.GITHUBLOGINCONFIG); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GITHUB_TRIGGER_CONFIG" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GITHUB_TRIGGER_CONFIG\": ")
	if tmp, err := json.Marshal(strct.GITHUBTRIGGERCONFIG); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GITLAB_TRIGGER_CONFIG" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GITLAB_TRIGGER_CONFIG\": ")
	if tmp, err := json.Marshal(strct.GITLABTRIGGERCONFIG); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "GOOGLE_LOGIN_CONFIG" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GOOGLE_LOGIN_CONFIG\": ")
	if tmp, err := json.Marshal(strct.GOOGLELOGINCONFIG); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "HEALTH_CHECKER" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"HEALTH_CHECKER\": ")
	if tmp, err := json.Marshal(strct.HEALTHCHECKER); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LOG_ARCHIVE_LOCATION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LOG_ARCHIVE_LOCATION\": ")
	if tmp, err := json.Marshal(strct.LOGARCHIVELOCATION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LOG_ARCHIVE_PATH" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LOG_ARCHIVE_PATH\": ")
	if tmp, err := json.Marshal(strct.LOGARCHIVEPATH); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LOGS_MODEL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LOGS_MODEL\": ")
	if tmp, err := json.Marshal(strct.LOGSMODEL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "LOGS_MODEL_CONFIG" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"LOGS_MODEL_CONFIG\": ")
	if tmp, err := json.Marshal(strct.LOGSMODELCONFIG); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MAIL_DEFAULT_SENDER" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MAIL_DEFAULT_SENDER\": ")
	if tmp, err := json.Marshal(strct.MAILDEFAULTSENDER); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MAIL_PASSWORD" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MAIL_PASSWORD\": ")
	if tmp, err := json.Marshal(strct.MAILPASSWORD); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MAIL_PORT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MAIL_PORT\": ")
	if tmp, err := json.Marshal(strct.MAILPORT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MAIL_SERVER" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MAIL_SERVER\": ")
	if tmp, err := json.Marshal(strct.MAILSERVER); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MAIL_USERNAME" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MAIL_USERNAME\": ")
	if tmp, err := json.Marshal(strct.MAILUSERNAME); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MAIL_USE_TLS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MAIL_USE_TLS\": ")
	if tmp, err := json.Marshal(strct.MAILUSETLS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "MAXIMUM_LAYER_SIZE" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"MAXIMUM_LAYER_SIZE\": ")
	if tmp, err := json.Marshal(strct.MAXIMUMLAYERSIZE); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PREFERREDURLSCHEME" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "PREFERRED_URL_SCHEME" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PREFERRED_URL_SCHEME\": ")
	if tmp, err := json.Marshal(strct.PREFERREDURLSCHEME); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PROMETHEUS_NAMESPACE" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PROMETHEUS_NAMESPACE\": ")
	if tmp, err := json.Marshal(strct.PROMETHEUSNAMESPACE); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PUBLIC_NAMESPACES" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PUBLIC_NAMESPACES\": ")
	if tmp, err := json.Marshal(strct.PUBLICNAMESPACES); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RECAPTCHA_SECRET_KEY" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RECAPTCHA_SECRET_KEY\": ")
	if tmp, err := json.Marshal(strct.RECAPTCHASECRETKEY); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "RECAPTCHA_SITE_KEY" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"RECAPTCHA_SITE_KEY\": ")
	if tmp, err := json.Marshal(strct.RECAPTCHASITEKEY); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "REGISTRY_STATE" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"REGISTRY_STATE\": ")
	if tmp, err := json.Marshal(strct.REGISTRYSTATE); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "REGISTRY_TITLE" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"REGISTRY_TITLE\": ")
	if tmp, err := json.Marshal(strct.REGISTRYTITLE); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "REGISTRY_TITLE_SHORT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"REGISTRY_TITLE_SHORT\": ")
	if tmp, err := json.Marshal(strct.REGISTRYTITLESHORT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "REPO_MIRROR_INTERVAL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"REPO_MIRROR_INTERVAL\": ")
	if tmp, err := json.Marshal(strct.REPOMIRRORINTERVAL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "REPO_MIRROR_SERVER_HOSTNAME" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"REPO_MIRROR_SERVER_HOSTNAME\": ")
	if tmp, err := json.Marshal(strct.REPOMIRRORSERVERHOSTNAME); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "REPO_MIRROR_TLS_VERIFY" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"REPO_MIRROR_TLS_VERIFY\": ")
	if tmp, err := json.Marshal(strct.REPOMIRRORTLSVERIFY); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SEARCH_MAX_RESULT_PAGE_COUNT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SEARCH_MAX_RESULT_PAGE_COUNT\": ")
	if tmp, err := json.Marshal(strct.SEARCHMAXRESULTPAGECOUNT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SEARCH_RESULTS_PER_PAGE" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SEARCH_RESULTS_PER_PAGE\": ")
	if tmp, err := json.Marshal(strct.SEARCHRESULTSPERPAGE); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SECURITY_SCANNER_ENDPOINT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SECURITY_SCANNER_ENDPOINT\": ")
	if tmp, err := json.Marshal(strct.SECURITYSCANNERENDPOINT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SECURITY_SCANNER_INDEXING_INTERVAL" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SECURITY_SCANNER_INDEXING_INTERVAL\": ")
	if tmp, err := json.Marshal(strct.SECURITYSCANNERINDEXINGINTERVAL); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SECURITY_SCANNER_V4_ENDPOINT" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SECURITY_SCANNER_V4_ENDPOINT\": ")
	if tmp, err := json.Marshal(strct.SECURITYSCANNERV4ENDPOINT); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SERVERHOSTNAME" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "SERVER_HOSTNAME" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SERVER_HOSTNAME\": ")
	if tmp, err := json.Marshal(strct.SERVERHOSTNAME); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SESSION_COOKIE_SECURE" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SESSION_COOKIE_SECURE\": ")
	if tmp, err := json.Marshal(strct.SESSIONCOOKIESECURE); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SSL_CIPHERS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SSL_CIPHERS\": ")
	if tmp, err := json.Marshal(strct.SSLCIPHERS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SSL_PROTOCOLS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SSL_PROTOCOLS\": ")
	if tmp, err := json.Marshal(strct.SSLPROTOCOLS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SUCCESSIVE_TRIGGER_FAILURE_DISABLE_THRESHOLD" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SUCCESSIVE_TRIGGER_FAILURE_DISABLE_THRESHOLD\": ")
	if tmp, err := json.Marshal(strct.SUCCESSIVETRIGGERFAILUREDISABLETHRESHOLD); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SUCCESSIVE_TRIGGER_INTERNAL_ERROR_DISABLE_THRESHOLD" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SUCCESSIVE_TRIGGER_INTERNAL_ERROR_DISABLE_THRESHOLD\": ")
	if tmp, err := json.Marshal(strct.SUCCESSIVETRIGGERINTERNALERRORDISABLETHRESHOLD); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "SUPER_USERS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"SUPER_USERS\": ")
	if tmp, err := json.Marshal(strct.SUPERUSERS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TAGEXPIRATIONOPTIONS" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "TAG_EXPIRATION_OPTIONS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TAG_EXPIRATION_OPTIONS\": ")
	if tmp, err := json.Marshal(strct.TAGEXPIRATIONOPTIONS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "TEAM_RESYNC_STALE_TIME" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"TEAM_RESYNC_STALE_TIME\": ")
	if tmp, err := json.Marshal(strct.TEAMRESYNCSTALETIME); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "USEREVENTSREDIS" field is required
    if strct.USEREVENTSREDIS == nil {
        return nil, errors.New("USER_EVENTS_REDIS is a required field")
    }
    // Marshal the "USER_EVENTS_REDIS" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"USER_EVENTS_REDIS\": ")
	if tmp, err := json.Marshal(strct.USEREVENTSREDIS); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "USERFILES_LOCATION" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"USERFILES_LOCATION\": ")
	if tmp, err := json.Marshal(strct.USERFILESLOCATION); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "USERFILES_PATH" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"USERFILES_PATH\": ")
	if tmp, err := json.Marshal(strct.USERFILESPATH); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "USER_RECOVERY_TOKEN_LIFETIME" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"USER_RECOVERY_TOKEN_LIFETIME\": ")
	if tmp, err := json.Marshal(strct.USERRECOVERYTOKENLIFETIME); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "V1_PUSH_WHITELIST" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"V1_PUSH_WHITELIST\": ")
	if tmp, err := json.Marshal(strct.V1PUSHWHITELIST); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "V2_PAGINATION_SIZE" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"V2_PAGINATION_SIZE\": ")
	if tmp, err := json.Marshal(strct.V2PAGINATIONSIZE); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "WEBHOOK_HOSTNAME_BLACKLIST" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"WEBHOOK_HOSTNAME_BLACKLIST\": ")
	if tmp, err := json.Marshal(strct.WEBHOOKHOSTNAMEBLACKLIST); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Root) UnmarshalJSON(b []byte) error {
    AUTHENTICATION_TYPEReceived := false
    BUILDLOGS_REDISReceived := false
    DB_URIReceived := false
    DEFAULT_TAG_EXPIRATIONReceived := false
    DISTRIBUTED_STORAGE_CONFIGReceived := false
    DISTRIBUTED_STORAGE_PREFERENCEReceived := false
    PREFERRED_URL_SCHEMEReceived := false
    SERVER_HOSTNAMEReceived := false
    TAG_EXPIRATION_OPTIONSReceived := false
    USER_EVENTS_REDISReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ACTION_LOG_ARCHIVE_LOCATION":
            if err := json.Unmarshal([]byte(v), &strct.ACTIONLOGARCHIVELOCATION); err != nil {
                return err
             }
        case "ACTION_LOG_ARCHIVE_PATH":
            if err := json.Unmarshal([]byte(v), &strct.ACTIONLOGARCHIVEPATH); err != nil {
                return err
             }
        case "ACTION_LOG_ROTATION_THRESHOLD":
            if err := json.Unmarshal([]byte(v), &strct.ACTIONLOGROTATIONTHRESHOLD); err != nil {
                return err
             }
        case "ALLOW_PULLS_WITHOUT_STRICT_LOGGING":
            if err := json.Unmarshal([]byte(v), &strct.ALLOWPULLSWITHOUTSTRICTLOGGING); err != nil {
                return err
             }
        case "APP_SPECIFIC_TOKEN_EXPIRATION":
            if err := json.Unmarshal([]byte(v), &strct.APPSPECIFICTOKENEXPIRATION); err != nil {
                return err
             }
        case "AUTHENTICATION_TYPE":
            if err := json.Unmarshal([]byte(v), &strct.AUTHENTICATIONTYPE); err != nil {
                return err
             }
            AUTHENTICATION_TYPEReceived = true
        case "AVATAR_KIND":
            if err := json.Unmarshal([]byte(v), &strct.AVATARKIND); err != nil {
                return err
             }
        case "BITBUCKET_TRIGGER_CONFIG":
            if err := json.Unmarshal([]byte(v), &strct.BITBUCKETTRIGGERCONFIG); err != nil {
                return err
             }
        case "BLACKLISTED_EMAIL_DOMAINS":
            if err := json.Unmarshal([]byte(v), &strct.BLACKLISTEDEMAILDOMAINS); err != nil {
                return err
             }
        case "BLACKLIST_V2_SPEC":
            if err := json.Unmarshal([]byte(v), &strct.BLACKLISTV2SPEC); err != nil {
                return err
             }
        case "BRANDING":
            if err := json.Unmarshal([]byte(v), &strct.BRANDING); err != nil {
                return err
             }
        case "BROWSER_API_CALLS_XHR_ONLY":
            if err := json.Unmarshal([]byte(v), &strct.BROWSERAPICALLSXHRONLY); err != nil {
                return err
             }
        case "BUILDLOGS_REDIS":
            if err := json.Unmarshal([]byte(v), &strct.BUILDLOGSREDIS); err != nil {
                return err
             }
            BUILDLOGS_REDISReceived = true
        case "CONTACT_INFO":
            if err := json.Unmarshal([]byte(v), &strct.CONTACTINFO); err != nil {
                return err
             }
        case "DB_CONNECTION_ARGS":
            if err := json.Unmarshal([]byte(v), &strct.DBCONNECTIONARGS); err != nil {
                return err
             }
        case "DB_URI":
            if err := json.Unmarshal([]byte(v), &strct.DBURI); err != nil {
                return err
             }
            DB_URIReceived = true
        case "DEFAULT_NAMESPACE_MAXIMUM_BUILD_COUNT":
            if err := json.Unmarshal([]byte(v), &strct.DEFAULTNAMESPACEMAXIMUMBUILDCOUNT); err != nil {
                return err
             }
        case "DEFAULT_TAG_EXPIRATION":
            if err := json.Unmarshal([]byte(v), &strct.DEFAULTTAGEXPIRATION); err != nil {
                return err
             }
            DEFAULT_TAG_EXPIRATIONReceived = true
        case "DIRECT_OAUTH_CLIENTID_WHITELIST":
            if err := json.Unmarshal([]byte(v), &strct.DIRECTOAUTHCLIENTIDWHITELIST); err != nil {
                return err
             }
        case "DISTRIBUTED_STORAGE_CONFIG":
            if err := json.Unmarshal([]byte(v), &strct.DISTRIBUTEDSTORAGECONFIG); err != nil {
                return err
             }
            DISTRIBUTED_STORAGE_CONFIGReceived = true
        case "DISTRIBUTED_STORAGE_DEFAULT_LOCATIONS":
            if err := json.Unmarshal([]byte(v), &strct.DISTRIBUTEDSTORAGEDEFAULTLOCATIONS); err != nil {
                return err
             }
        case "DISTRIBUTED_STORAGE_PREFERENCE":
            if err := json.Unmarshal([]byte(v), &strct.DISTRIBUTEDSTORAGEPREFERENCE); err != nil {
                return err
             }
            DISTRIBUTED_STORAGE_PREFERENCEReceived = true
        case "DOCUMENTATION_ROOT":
            if err := json.Unmarshal([]byte(v), &strct.DOCUMENTATIONROOT); err != nil {
                return err
             }
        case "ENABLE_HEALTH_DEBUG_SECRET":
            if err := json.Unmarshal([]byte(v), &strct.ENABLEHEALTHDEBUGSECRET); err != nil {
                return err
             }
        case "EXPIRED_APP_SPECIFIC_TOKEN_GC":
            if err := json.Unmarshal([]byte(v), &strct.EXPIREDAPPSPECIFICTOKENGC); err != nil {
                return err
             }
        case "EXTERNAL_TLS_TERMINATION":
            if err := json.Unmarshal([]byte(v), &strct.EXTERNALTLSTERMINATION); err != nil {
                return err
             }
        case "FEATURE_ACI_CONVERSION":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREACICONVERSION); err != nil {
                return err
             }
        case "FEATURE_ACTION_LOG_ROTATION":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREACTIONLOGROTATION); err != nil {
                return err
             }
        case "FEATURE_ADVERTISE_V2":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREADVERTISEV2); err != nil {
                return err
             }
        case "FEATURE_AGGREGATED_LOG_COUNT_RETRIEVAL":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREAGGREGATEDLOGCOUNTRETRIEVAL); err != nil {
                return err
             }
        case "FEATURE_ANONYMOUS_ACCESS":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREANONYMOUSACCESS); err != nil {
                return err
             }
        case "FEATURE_APP_REGISTRY":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREAPPREGISTRY); err != nil {
                return err
             }
        case "FEATURE_APP_SPECIFIC_TOKENS":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREAPPSPECIFICTOKENS); err != nil {
                return err
             }
        case "FEATURE_BITBUCKET_BUILD":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREBITBUCKETBUILD); err != nil {
                return err
             }
        case "FEATURE_BLACKLISTED_EMAILS":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREBLACKLISTEDEMAILS); err != nil {
                return err
             }
        case "FEATURE_BUILD_SUPPORT":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREBUILDSUPPORT); err != nil {
                return err
             }
        case "FEATURE_CHANGE_TAG_EXPIRATION":
            if err := json.Unmarshal([]byte(v), &strct.FEATURECHANGETAGEXPIRATION); err != nil {
                return err
             }
        case "FEATURE_DIRECT_LOGIN":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREDIRECTLOGIN); err != nil {
                return err
             }
        case "FEATURE_GARBAGE_COLLECTION":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREGARBAGECOLLECTION); err != nil {
                return err
             }
        case "FEATURE_GITHUB_BUILD":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREGITHUBBUILD); err != nil {
                return err
             }
        case "FEATURE_GITHUB_LOGIN":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREGITHUBLOGIN); err != nil {
                return err
             }
        case "FEATURE_GITLAB_BUILD":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREGITLABBUILD); err != nil {
                return err
             }
        case "FEATURE_GOOGLE_LOGIN":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREGOOGLELOGIN); err != nil {
                return err
             }
        case "FEATURE_INVITE_ONLY_USER_CREATION":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREINVITEONLYUSERCREATION); err != nil {
                return err
             }
        case "FEATURE_LIBRARY_SUPPORT":
            if err := json.Unmarshal([]byte(v), &strct.FEATURELIBRARYSUPPORT); err != nil {
                return err
             }
        case "FEATURE_LOG_EXPORT":
            if err := json.Unmarshal([]byte(v), &strct.FEATURELOGEXPORT); err != nil {
                return err
             }
        case "FEATURE_MAILING":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREMAILING); err != nil {
                return err
             }
        case "FEATURE_NONSUPERUSER_TEAM_SYNCING_SETUP":
            if err := json.Unmarshal([]byte(v), &strct.FEATURENONSUPERUSERTEAMSYNCINGSETUP); err != nil {
                return err
             }
        case "FEATURE_PARTIAL_USER_AUTOCOMPLETE":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREPARTIALUSERAUTOCOMPLETE); err != nil {
                return err
             }
        case "FEATURE_PERMANENT_SESSIONS":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREPERMANENTSESSIONS); err != nil {
                return err
             }
        case "FEATURE_PROXY_STORAGE":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREPROXYSTORAGE); err != nil {
                return err
             }
        case "FEATURE_PUBLIC_CATALOG":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREPUBLICCATALOG); err != nil {
                return err
             }
        case "FEATURE_RATE_LIMITS":
            if err := json.Unmarshal([]byte(v), &strct.FEATURERATELIMITS); err != nil {
                return err
             }
        case "FEATURE_READER_BUILD_LOGS":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREREADERBUILDLOGS); err != nil {
                return err
             }
        case "FEATURE_READONLY_APP_REGISTRY":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREREADONLYAPPREGISTRY); err != nil {
                return err
             }
        case "FEATURE_RECAPTCHA":
            if err := json.Unmarshal([]byte(v), &strct.FEATURERECAPTCHA); err != nil {
                return err
             }
        case "FEATURE_REPO_MIRROR":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREREPOMIRROR); err != nil {
                return err
             }
        case "FEATURE_REQUIRE_ENCRYPTED_BASIC_AUTH":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREREQUIREENCRYPTEDBASICAUTH); err != nil {
                return err
             }
        case "FEATURE_REQUIRE_TEAM_INVITE":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREREQUIRETEAMINVITE); err != nil {
                return err
             }
        case "FEATURE_RESTRICTED_V1_PUSH":
            if err := json.Unmarshal([]byte(v), &strct.FEATURERESTRICTEDV1PUSH); err != nil {
                return err
             }
        case "FEATURE_SECURITY_NOTIFICATIONS":
            if err := json.Unmarshal([]byte(v), &strct.FEATURESECURITYNOTIFICATIONS); err != nil {
                return err
             }
        case "FEATURE_SECURITY_SCANNER":
            if err := json.Unmarshal([]byte(v), &strct.FEATURESECURITYSCANNER); err != nil {
                return err
             }
        case "FEATURE_STORAGE_REPLICATION":
            if err := json.Unmarshal([]byte(v), &strct.FEATURESTORAGEREPLICATION); err != nil {
                return err
             }
        case "FEATURE_SUPER_USERS":
            if err := json.Unmarshal([]byte(v), &strct.FEATURESUPERUSERS); err != nil {
                return err
             }
        case "FEATURE_TEAM_SYNCING":
            if err := json.Unmarshal([]byte(v), &strct.FEATURETEAMSYNCING); err != nil {
                return err
             }
        case "FEATURE_USER_CREATION":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREUSERCREATION); err != nil {
                return err
             }
        case "FEATURE_USER_LAST_ACCESSED":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREUSERLASTACCESSED); err != nil {
                return err
             }
        case "FEATURE_USER_LOG_ACCESS":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREUSERLOGACCESS); err != nil {
                return err
             }
        case "FEATURE_USER_METADATA":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREUSERMETADATA); err != nil {
                return err
             }
        case "FEATURE_USERNAME_CONFIRMATION":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREUSERNAMECONFIRMATION); err != nil {
                return err
             }
        case "FEATURE_USER_RENAME":
            if err := json.Unmarshal([]byte(v), &strct.FEATUREUSERRENAME); err != nil {
                return err
             }
        case "FRESH_LOGIN_TIMEOUT":
            if err := json.Unmarshal([]byte(v), &strct.FRESHLOGINTIMEOUT); err != nil {
                return err
             }
        case "GITHUB_LOGIN_CONFIG":
            if err := json.Unmarshal([]byte(v), &strct.GITHUBLOGINCONFIG); err != nil {
                return err
             }
        case "GITHUB_TRIGGER_CONFIG":
            if err := json.Unmarshal([]byte(v), &strct.GITHUBTRIGGERCONFIG); err != nil {
                return err
             }
        case "GITLAB_TRIGGER_CONFIG":
            if err := json.Unmarshal([]byte(v), &strct.GITLABTRIGGERCONFIG); err != nil {
                return err
             }
        case "GOOGLE_LOGIN_CONFIG":
            if err := json.Unmarshal([]byte(v), &strct.GOOGLELOGINCONFIG); err != nil {
                return err
             }
        case "HEALTH_CHECKER":
            if err := json.Unmarshal([]byte(v), &strct.HEALTHCHECKER); err != nil {
                return err
             }
        case "LOG_ARCHIVE_LOCATION":
            if err := json.Unmarshal([]byte(v), &strct.LOGARCHIVELOCATION); err != nil {
                return err
             }
        case "LOG_ARCHIVE_PATH":
            if err := json.Unmarshal([]byte(v), &strct.LOGARCHIVEPATH); err != nil {
                return err
             }
        case "LOGS_MODEL":
            if err := json.Unmarshal([]byte(v), &strct.LOGSMODEL); err != nil {
                return err
             }
        case "LOGS_MODEL_CONFIG":
            if err := json.Unmarshal([]byte(v), &strct.LOGSMODELCONFIG); err != nil {
                return err
             }
        case "MAIL_DEFAULT_SENDER":
            if err := json.Unmarshal([]byte(v), &strct.MAILDEFAULTSENDER); err != nil {
                return err
             }
        case "MAIL_PASSWORD":
            if err := json.Unmarshal([]byte(v), &strct.MAILPASSWORD); err != nil {
                return err
             }
        case "MAIL_PORT":
            if err := json.Unmarshal([]byte(v), &strct.MAILPORT); err != nil {
                return err
             }
        case "MAIL_SERVER":
            if err := json.Unmarshal([]byte(v), &strct.MAILSERVER); err != nil {
                return err
             }
        case "MAIL_USERNAME":
            if err := json.Unmarshal([]byte(v), &strct.MAILUSERNAME); err != nil {
                return err
             }
        case "MAIL_USE_TLS":
            if err := json.Unmarshal([]byte(v), &strct.MAILUSETLS); err != nil {
                return err
             }
        case "MAXIMUM_LAYER_SIZE":
            if err := json.Unmarshal([]byte(v), &strct.MAXIMUMLAYERSIZE); err != nil {
                return err
             }
        case "PREFERRED_URL_SCHEME":
            if err := json.Unmarshal([]byte(v), &strct.PREFERREDURLSCHEME); err != nil {
                return err
             }
            PREFERRED_URL_SCHEMEReceived = true
        case "PROMETHEUS_NAMESPACE":
            if err := json.Unmarshal([]byte(v), &strct.PROMETHEUSNAMESPACE); err != nil {
                return err
             }
        case "PUBLIC_NAMESPACES":
            if err := json.Unmarshal([]byte(v), &strct.PUBLICNAMESPACES); err != nil {
                return err
             }
        case "RECAPTCHA_SECRET_KEY":
            if err := json.Unmarshal([]byte(v), &strct.RECAPTCHASECRETKEY); err != nil {
                return err
             }
        case "RECAPTCHA_SITE_KEY":
            if err := json.Unmarshal([]byte(v), &strct.RECAPTCHASITEKEY); err != nil {
                return err
             }
        case "REGISTRY_STATE":
            if err := json.Unmarshal([]byte(v), &strct.REGISTRYSTATE); err != nil {
                return err
             }
        case "REGISTRY_TITLE":
            if err := json.Unmarshal([]byte(v), &strct.REGISTRYTITLE); err != nil {
                return err
             }
        case "REGISTRY_TITLE_SHORT":
            if err := json.Unmarshal([]byte(v), &strct.REGISTRYTITLESHORT); err != nil {
                return err
             }
        case "REPO_MIRROR_INTERVAL":
            if err := json.Unmarshal([]byte(v), &strct.REPOMIRRORINTERVAL); err != nil {
                return err
             }
        case "REPO_MIRROR_SERVER_HOSTNAME":
            if err := json.Unmarshal([]byte(v), &strct.REPOMIRRORSERVERHOSTNAME); err != nil {
                return err
             }
        case "REPO_MIRROR_TLS_VERIFY":
            if err := json.Unmarshal([]byte(v), &strct.REPOMIRRORTLSVERIFY); err != nil {
                return err
             }
        case "SEARCH_MAX_RESULT_PAGE_COUNT":
            if err := json.Unmarshal([]byte(v), &strct.SEARCHMAXRESULTPAGECOUNT); err != nil {
                return err
             }
        case "SEARCH_RESULTS_PER_PAGE":
            if err := json.Unmarshal([]byte(v), &strct.SEARCHRESULTSPERPAGE); err != nil {
                return err
             }
        case "SECURITY_SCANNER_ENDPOINT":
            if err := json.Unmarshal([]byte(v), &strct.SECURITYSCANNERENDPOINT); err != nil {
                return err
             }
        case "SECURITY_SCANNER_INDEXING_INTERVAL":
            if err := json.Unmarshal([]byte(v), &strct.SECURITYSCANNERINDEXINGINTERVAL); err != nil {
                return err
             }
        case "SECURITY_SCANNER_V4_ENDPOINT":
            if err := json.Unmarshal([]byte(v), &strct.SECURITYSCANNERV4ENDPOINT); err != nil {
                return err
             }
        case "SERVER_HOSTNAME":
            if err := json.Unmarshal([]byte(v), &strct.SERVERHOSTNAME); err != nil {
                return err
             }
            SERVER_HOSTNAMEReceived = true
        case "SESSION_COOKIE_SECURE":
            if err := json.Unmarshal([]byte(v), &strct.SESSIONCOOKIESECURE); err != nil {
                return err
             }
        case "SSL_CIPHERS":
            if err := json.Unmarshal([]byte(v), &strct.SSLCIPHERS); err != nil {
                return err
             }
        case "SSL_PROTOCOLS":
            if err := json.Unmarshal([]byte(v), &strct.SSLPROTOCOLS); err != nil {
                return err
             }
        case "SUCCESSIVE_TRIGGER_FAILURE_DISABLE_THRESHOLD":
            if err := json.Unmarshal([]byte(v), &strct.SUCCESSIVETRIGGERFAILUREDISABLETHRESHOLD); err != nil {
                return err
             }
        case "SUCCESSIVE_TRIGGER_INTERNAL_ERROR_DISABLE_THRESHOLD":
            if err := json.Unmarshal([]byte(v), &strct.SUCCESSIVETRIGGERINTERNALERRORDISABLETHRESHOLD); err != nil {
                return err
             }
        case "SUPER_USERS":
            if err := json.Unmarshal([]byte(v), &strct.SUPERUSERS); err != nil {
                return err
             }
        case "TAG_EXPIRATION_OPTIONS":
            if err := json.Unmarshal([]byte(v), &strct.TAGEXPIRATIONOPTIONS); err != nil {
                return err
             }
            TAG_EXPIRATION_OPTIONSReceived = true
        case "TEAM_RESYNC_STALE_TIME":
            if err := json.Unmarshal([]byte(v), &strct.TEAMRESYNCSTALETIME); err != nil {
                return err
             }
        case "USER_EVENTS_REDIS":
            if err := json.Unmarshal([]byte(v), &strct.USEREVENTSREDIS); err != nil {
                return err
             }
            USER_EVENTS_REDISReceived = true
        case "USERFILES_LOCATION":
            if err := json.Unmarshal([]byte(v), &strct.USERFILESLOCATION); err != nil {
                return err
             }
        case "USERFILES_PATH":
            if err := json.Unmarshal([]byte(v), &strct.USERFILESPATH); err != nil {
                return err
             }
        case "USER_RECOVERY_TOKEN_LIFETIME":
            if err := json.Unmarshal([]byte(v), &strct.USERRECOVERYTOKENLIFETIME); err != nil {
                return err
             }
        case "V1_PUSH_WHITELIST":
            if err := json.Unmarshal([]byte(v), &strct.V1PUSHWHITELIST); err != nil {
                return err
             }
        case "V2_PAGINATION_SIZE":
            if err := json.Unmarshal([]byte(v), &strct.V2PAGINATIONSIZE); err != nil {
                return err
             }
        case "WEBHOOK_HOSTNAME_BLACKLIST":
            if err := json.Unmarshal([]byte(v), &strct.WEBHOOKHOSTNAMEBLACKLIST); err != nil {
                return err
             }
        }
    }
    // check if AUTHENTICATION_TYPE (a required property) was received
    if !AUTHENTICATION_TYPEReceived {
        return errors.New("\"AUTHENTICATION_TYPE\" is required but was not present")
    }
    // check if BUILDLOGS_REDIS (a required property) was received
    if !BUILDLOGS_REDISReceived {
        return errors.New("\"BUILDLOGS_REDIS\" is required but was not present")
    }
    // check if DB_URI (a required property) was received
    if !DB_URIReceived {
        return errors.New("\"DB_URI\" is required but was not present")
    }
    // check if DEFAULT_TAG_EXPIRATION (a required property) was received
    if !DEFAULT_TAG_EXPIRATIONReceived {
        return errors.New("\"DEFAULT_TAG_EXPIRATION\" is required but was not present")
    }
    // check if DISTRIBUTED_STORAGE_CONFIG (a required property) was received
    if !DISTRIBUTED_STORAGE_CONFIGReceived {
        return errors.New("\"DISTRIBUTED_STORAGE_CONFIG\" is required but was not present")
    }
    // check if DISTRIBUTED_STORAGE_PREFERENCE (a required property) was received
    if !DISTRIBUTED_STORAGE_PREFERENCEReceived {
        return errors.New("\"DISTRIBUTED_STORAGE_PREFERENCE\" is required but was not present")
    }
    // check if PREFERRED_URL_SCHEME (a required property) was received
    if !PREFERRED_URL_SCHEMEReceived {
        return errors.New("\"PREFERRED_URL_SCHEME\" is required but was not present")
    }
    // check if SERVER_HOSTNAME (a required property) was received
    if !SERVER_HOSTNAMEReceived {
        return errors.New("\"SERVER_HOSTNAME\" is required but was not present")
    }
    // check if TAG_EXPIRATION_OPTIONS (a required property) was received
    if !TAG_EXPIRATION_OPTIONSReceived {
        return errors.New("\"TAG_EXPIRATION_OPTIONS\" is required but was not present")
    }
    // check if USER_EVENTS_REDIS (a required property) was received
    if !USER_EVENTS_REDISReceived {
        return errors.New("\"USER_EVENTS_REDIS\" is required but was not present")
    }
    return nil
}

func (strct *Ssl) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Ca" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ca" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"ca\": ")
	if tmp, err := json.Marshal(strct.Ca); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Ssl) UnmarshalJSON(b []byte) error {
    caReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ca":
            if err := json.Unmarshal([]byte(v), &strct.Ca); err != nil {
                return err
             }
            caReceived = true
        }
    }
    // check if ca (a required property) was received
    if !caReceived {
        return errors.New("\"ca\" is required but was not present")
    }
    return nil
}

func (strct *USEREVENTSREDIS) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Host" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "password" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"password\": ")
	if tmp, err := json.Marshal(strct.Password); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *USEREVENTSREDIS) UnmarshalJSON(b []byte) error {
    hostReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
            hostReceived = true
        case "password":
            if err := json.Unmarshal([]byte(v), &strct.Password); err != nil {
                return err
             }
        case "port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        }
    }
    // check if host (a required property) was received
    if !hostReceived {
        return errors.New("\"host\" is required but was not present")
    }
    return nil
}
