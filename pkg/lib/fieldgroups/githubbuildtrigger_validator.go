package fieldgroups

import (
	"fmt"
	"net/http"

	"cuelang.org/go/pkg/strings"
)

// Validate checks the configuration settings for this field group
func (fg *GitHubBuildTriggerFieldGroup) Validate() []ValidationError {

	// Make empty errors
	errors := []ValidationError{}

	// If build support is off, return false
	if fg.FeatureBuildSupport == false {
		return errors
	}

	// If github trigger is off
	if fg.FeatureGithubBuild == false {
		return errors
	}

	// Check for config
	if fg.GithubTriggerConfig == nil {
		newError := ValidationError{
			Tags:    []string{"GITHUB_TRIGGER_CONFIG"},
			Policy:  "A is Required",
			Message: "GITHUB_TRIGGER_CONFIG is required for GitHubBuildTrigger",
		}
		errors = append(errors, newError)
		return errors
	}

	// Check for endpoint
	if fg.GithubTriggerConfig.GithubEndpoint == "" {
		newError := ValidationError{
			Tags:    []string{"GITHUB_TRIGGER_CONFIG.GITHUB_ENDPOINT"},
			Policy:  "A is Required",
			Message: "GITHUB_TRIGGER_CONFIG.GITHUB_ENDPOINT is required for GitHubBuildTrigger",
		}
		errors = append(errors, newError)
	}

	// Check for endpoint
	if !strings.HasPrefix(fg.GithubTriggerConfig.GithubEndpoint, "http://") && !strings.HasPrefix(fg.GithubTriggerConfig.GithubEndpoint, "https://") {
		newError := ValidationError{
			Tags:    []string{"GITHUB_TRIGGER_CONFIG.GITHUB_ENDPOINT"},
			Policy:  "A is URL",
			Message: "GITHUB_TRIGGER_CONFIG.GITHUB_ENDPOINT must be a url",
		}
		errors = append(errors, newError)
	}

	// Check for client id
	if fg.GithubTriggerConfig.ClientId == "" {
		newError := ValidationError{
			Tags:    []string{"GITHUB_TRIGGER_CONFIG.CLIENT_ID"},
			Policy:  "A is Required",
			Message: "GITHUB_TRIGGER_CONFIG.CLIENT_ID is required for GitHubBuildTrigger",
		}
		errors = append(errors, newError)
	}

	// Check for endpoint
	if fg.GithubTriggerConfig.ClientSecret == "" {
		newError := ValidationError{
			Tags:    []string{"GITHUB_TRIGGER_CONFIG.CLIENT_SECRET"},
			Policy:  "A is Required",
			Message: "GITHUB_TRIGGER_CONFIG.CLIENT_SECRET is required for GitHubBuildTrigger",
		}
		errors = append(errors, newError)
	}

	// If restricted orgs, make sure
	if fg.GithubTriggerConfig.OrgRestrict == true && len(fg.GithubTriggerConfig.AllowedOrganizations) == 0 {
		newError := ValidationError{
			Tags:    []string{"GITHUB_TRIGGER_CONFIG.ORG_RESTRICT", "GITHUB_TRIGGER_CONFIG.ALLOWED_ORGANIZATIONS"},
			Policy:  "A is Required",
			Message: "GITHUB_TRIGGER_CONFIG.ALLOWED_ORGANIZATIONS must contain values if GITHUB_TRIGGER_CONFIG.ORG_RESTRICT is true",
		}
		errors = append(errors, newError)
	}

	return errors

}

// ValidateGitHubOAuth checks that the Bitbucker OAuth credentials are correct
func ValidateGitHubOAuth(clientID, clientSecret string) bool {

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	req, err := http.NewRequest("GET", "https://api.github.com/", nil)
	if err != nil {
		// handle err
	}
	req.SetBasicAuth("fc0ef3cf19f90de48af9", "8bd923a5768a59f2e5f848752fa71ae62f4991ce")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()

	fmt.Println(resp.StatusCode)

	return true

}
